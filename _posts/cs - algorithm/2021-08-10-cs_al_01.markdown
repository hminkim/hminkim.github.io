---
layout: post
title: "[Algorithm] Shortest Path Problem"
subtitle:  "Shortest Path Problem"
categories: computerscience
tags: algorithm
---
  
## Shortest Path Problem 최단 경로 문제  
  
- 최단 경로 문제란 두 노드를 잇는 가장 짧은 경로를 찾는 문제  
- 가중치 그래프 (Weighted Graph) 에서 간선 (Edge)의 가중치 합이 최소가 되도록 하는 경로를 찾는 것이 목적  
  
### 최단 경로 문제 종류  
  
- 단일 출발 및 단일 도착 (single-source and single-destination shortest path problem) 최단 경로 문제  
    - 그래프 내의 특정 노드 u 에서 출발, 또다른 특정 노드 v 에 도착하는 가장 짧은 경로를 찾는 문제  
- 단일 출발 (single-source shortest path problem) 최단 경로 문제  
    - 그래프 내의 특정 노드 u 와 그래프 내 다른 모든 노드 각각의 가장 짧은 경로를 찾는 문제  
- 전체 쌍(all-pair) 최단 경로 문제  
    - 그래프 내의 모든 노드 쌍 (u, v) 에 대한 최단 경로를 찾는 문제  
  
<br>
   
<center><img src="/assets/img/cs_al_210810_1.png" width="100%" height="100%"></center>  
<center>출처 : https://shnoh.tistory.com/15</center>  
<center> 상황에 따라 사용해야 할 최단 경로 문제 알고리즘 </center>  
   
<br>
  
---  
      
## Dijkstra Algorithm 다익스트라 알고리즘  
  
- 하나의 정점에서 다른 모든 정점 간의 각각 가장 짧은 거리를 구하는 단일 출발 최단 경로 문제에 적합  
- 첫 정점을 기준으로 연결되어 있는 정점들을 추가해 가며, 최단 거리를 갱신하는 기법으로 BFS와 유사  
  
<br>
  
### 다익스트라 알고리즘 로직  
  
- 다익스트라 알고리즘의 다양한 변형 로직이 있지만, 본 포스팅에서는 가장 개선된 우선순위 큐를 사용하는 방식을 사용  
    - 우선순위 큐는 최소 힙 방식을 활용해서, 현재 가장 짧은 거리를 가진 노드 정보를 먼저 꺼냄  
  
1. 첫 정점을 기준으로 배열을 선언하여 첫 정점에서 각 정점까지의 거리를 저장  
    - 시간을 단축시키기 위해 접근이 빠른 해시테이블의 성질을 띄는 딕셔너리로 선언  
    - 초기에는 첫 정점의 거리는 0, 나머지는 무한대(inf)로 저장  
    - 우선순위 큐에 (첫 정점, 거리 0)만 먼저 넣음  
  
2. 우선순위 큐에서 노드를 꺼냄  
    - 처음에는 첫 정점만 저장되어 있으므로, 첫 정점이 꺼내짐  
    - 첫 정점에 인접한 노드들 각각에 대해, 첫 정점에서 각 노드로 가는 거리와 현재 배열에 저장되어 있는 첫 정점에서 각 정점까지의 거리를 비교  
    - 배열에 저장되어 있는 거리보다, 첫 정점에서 해당 노드로 가는 거리가 더 짧을 경우, 배열에 해당 노드의 거리로 업데이트  
    - 배열에 해당 노드의 거리가 업데이트된 경우, 우선순위 큐에 삽입   
    - 결과적으로 너비 우선 탐색 방식과 유사하게, 첫 정점에 인접한 노드들을 순차적으로 방문  
    - 만약 배열에 기록된 현재까지 발견된 가장 짧은 거리보다, 더 긴 거리(루트)를 가진 (노드, 거리)의 경우에는 해당 노드와 인접한 노드간의 거리 계산을 하지 않음  
  
3. 2번의 과정을 우선순위 큐에 꺼낼 노드가 없을 때까지 반복   
  
<br>
   
<center><img src="/assets/img/cs_al_210810_2.png" width="100%" height="100%"></center>  
<center>출처 : https://shnoh.tistory.com/15</center>  
<center> 우선순위 큐 방삭의 다익스트라 알고리즘 로직 </center>  
   
<br>
   
### 다익스트라 알고리즘 구현   

<br>
   
<center><img src="/assets/img/cs_al_210810_2.png" width="80%" height="80%"></center>  
<center>출처 : https://www.fun-coding.org/Chapter20-shortest-live.html</center>  
<center> 다익스트라 알고리즘 구현을 위한 그래프 예시 </center>  
   
<br>
  
```python
import heapq

graph = {
    'A': {'B': 8, 'C': 1, 'D': 2},
    'B': {},
    'C': {'B': 5, 'D': 2},
    'D': {'E': 3, 'F': 5},
    'E': {'F': 1},
    'F': {'A': 5}
}

def dijkstra(graph, start):
    
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    queue = []
    heapq.heappush(queue, [distances[start], start])
    
    while queue:
        current_distance, current_node = heapq.heappop(queue)
        
        if distances[current_node] < current_distance:
            continue
            
        for adjacent, weight in graph[current_node].items():
            distance = current_distance + weight
            
            if distance < distances[adjacent]:
                distances[adjacent] = distance
                heapq.heappush(queue, [distance, adjacent])
                
    return distances
```
<center> 우선순위 큐 방식의 다익스트라 알고리즘을 파이썬으로 구현 </center>
  
<br>
   
### 다익스트라 알고리즘 시간 복잡도  
  
- 노드 수 : V / 간선 수 : E  

**과정 1 (각 노드마다 인접한 간선들을 모두 검사)**  
    - 각 노드는 최대 한 번씩 방문하므로 (첫 노드와 해당 노드간의 갈 수 있는 루트가 있는 경우만 해당), 그래프의 모든 간선은 최대 한 번씩 검사  
    - 각 노드마다 인접한 간선들을 모두 검사하는 과정은 O(E) 시간이 걸림  
**과정 2 (우선순위 큐에 노드/거리 정보를 넣고 삭제 하는 과정)**  
    - 우선순위 큐에 가장 많은 노드, 거리 정보가 들어가는 경우, 우선순위 큐에 노드/거리 정보를 넣고, 삭제하는 과정이 최악의 시간이 걸림  

- 우선순위 큐에 가장 많은 노드, 거리 정보가 들어가는 시나리오는 그래프의 모든 간선이 검사될 때마다, 배열의 최단 거리가 갱신되고, 우선순위 큐에 노드/거리가 추가되는 것  
- 이 때 추가는 각 간선마다 최대 한 번 일어날 수 있으므로, 최대 O(E)의 시간이 걸리고, O(E) 개의 노드/거리 정보에 대해 우선순위 큐를 유지하는 작업은  O(logE)가 걸림  
- 직관적으로 전체 과정은 **O(E + ElogE)** -> E개의 원소를 우선순위 큐에 넣었다가 모두 빼내는 연산과 매우 유사  
- 대개의 중복 간선이 없는 경우, 그래프에서 간선의 개수 E는 V^2보다 작기 때문에 O(logE)=O(logV)  
    - 따라서 우선순위 큐를 활용한 다익스트라 알고리즘의 시간 복잡도는 **O(ElogV)**로 표기 가능  
  
- 간선이 V^2보다 한참 적은 희소 그래프가 아닌 정점의 수가 적거나 간선의 수가 매우 많은 밀집 그래프일 경우에는 아예 우선순위 큐를 사용하지 않고 구현하는 방식이 더욱 빠른 경우가 있음  
- 다음에 방문 할 정점을 매번 반복문을 이용해 방문하지 않은 정점 중 거리가 가장 작은 값을 찾아 각 정점을 방문했는지 여부를 우선 순위 큐가 아닌 일반적인 연결 리스트나 배열로 저장 
    - 이 경우 다익스트라 알고리즘의 시간 복잡도는 **O(V^2+E)** -> **O(V^2)**로 표기 가능
  
<br>
  
---  
  
## Bellman-Ford algorithm 벨먼-포드 알고리즘
  
- .

### .
- .  
  
<br>
  
---  
  
## Floyd-Warshall Algorithm 플로이드-워셜 알고리즘
  
- .  

### .
- .  
  
<br>
  
----  
  
### 참고  
  
[잔재미코딩](https://www.fun-coding.org/Chapter20-shortest-live.html)  
[신찬수 교수님 유튜브](https://www.youtube.com/user/cssin829)  
[위키 백과](https://ko.wikipedia.org/wiki/%EC%B5%9C%EB%8B%A8_%EA%B2%BD%EB%A1%9C_%EB%AC%B8%EC%A0%9C)  
[shnoh's Blog](https://shnoh.tistory.com/15)  
  
----  
  