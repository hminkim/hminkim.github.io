var tipuesearch = {"pages": [{
    "title": "Heap",
    "text": "Heap 힙 데이터에서 최대값이나 최소값을 빠르게 찾기 위해 고안된 완전 이진 트리 배열에 데이터를 넣고 최대값이나 최소값을 찾으려면 O(n)의 시간이 걸리지만, 힙에서는 O(logn)이 걸림 우선순위 큐와 같이 최대값 또는 최소값을 빠르게 찾아야 하는 자료구조 및 알고리즘 등에 활용됨 힙에는 부모노드의 키 값이 자식노드의 키 값보다 항상 큰 ‘최대 힙’과 부모노드의 키 값이 자식노드의 키 값보다 항상 작은 ‘최소 힙’ 두가지의 종류가 있음 출처 : https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html 힙의 형태 일반적으로 힙을 저장하는 자료구조로는 배열로 구현 구현의 편의성을 위해 배열의 첫번째 인덱스(0)은 None으로 비워 둠 (부모 노드 인덱스) = (자식 노드 인덱스) // 2 (왼쪽 자식 노드 인덱스) = (부모 노드 인덱스) * 2 (오른쪽 자식 노드 인덱스) = (부모 노드 인덱스) * 2 + 1 출처 : https://www.fun-coding.org/Chapter11-heap.html 힙과 이진 탐색 트리의 차이점 완전 이진 트리인 힙과 이진 탐색 트리는 여러 차이점이 있음 힙은 각 노드의 값이 자식 노드보다 크거나 같음 (최대 힙일 경우 / 최소 힙이면 반대) 이진 탐색 트리는 왼쪽 자식 노드의 값이 가장 작고 오른쪽 자식 노드가 가장 크지만, 힙은 작은 값은 왼쪽, 큰 값은 오른쪽이라는 조건은 없음 이진 탐색 트리는 탐색을 위한 구조이고 힙은 최대,최소값 검색을 위한 구조 중 하나 힙 구현 출처 : https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html 힙의 삽입 힙에 새로운 요소가 들어오면 일단 새로운 노드를 힙의 마지막 노드에 이어서 삽입 한 후 새 노드를 부모 노드들과 교환하여 힙의 성질을 만족시킴 힙의 삽입에는 O(logn)의 시간이 소요됨 출처 : https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html 힙의 삭제 (최대/최소값) 최대 힙에서 최대값은 루트 노드이므로 루트 노드 삭제 후 삭제된 힙의 마지막 노드를 루트 노드에 가져와서 힙을 재구성 함 힙의 삭제에는 O(logn)의 시간이 소요됨 class Heap: def __init__(self, data): self.heap_array = list() self.heap_array.append(None) self.heap_array.append(data) def move_down(self, popped_idx): left_child_popped_idx = popped_idx * 2 right_child_popped_idx = popped_idx * 2 + 1 # case1: 자식 노드가 없을 때 if left_child_popped_idx &gt;= len(self.heap_array): return False # case2: 오른쪽 자식 노드만 없을 때 elif right_child_popped_idx &gt;= len(self.heap_array): if self.heap_array[popped_idx] &lt; self.heap_array[left_child_popped_idx]: return True else: return False # case3: 왼쪽, 오른쪽 자식 노드 모두 있을 때 else: if self.heap_array[left_child_popped_idx] &gt; self.heap_array[right_child_popped_idx]: if self.heap_array[popped_idx] &lt; self.heap_array[left_child_popped_idx]: return True else: return False else: if self.heap_array[popped_idx] &lt; self.heap_array[right_child_popped_idx]: return True else: return False def pop(self): if len(self.heap_array) &lt;= 1: return None returned_data = self.heap_array[1] self.heap_array[1] = self.heap_array[-1] del self.heap_array[-1] popped_idx = 1 while self.move_down(popped_idx): left_child_popped_idx = popped_idx * 2 right_child_popped_idx = popped_idx * 2 + 1 # case2: 오른쪽 자식 노드만 없을 때 if right_child_popped_idx &gt;= len(self.heap_array): if self.heap_array[popped_idx] &lt; self.heap_array[left_child_popped_idx]: self.heap_array[popped_idx], self.heap_array[left_child_popped_idx] = self.heap_array[left_child_popped_idx], self.heap_array[popped_idx] popped_idx = left_child_popped_idx # case3: 왼쪽, 오른쪽 자식 노드 모두 있을 때 else: if self.heap_array[left_child_popped_idx] &gt; self.heap_array[right_child_popped_idx]: if self.heap_array[popped_idx] &lt; self.heap_array[left_child_popped_idx]: self.heap_array[popped_idx], self.heap_array[left_child_popped_idx] = self.heap_array[left_child_popped_idx], self.heap_array[popped_idx] popped_idx = left_child_popped_idx else: if self.heap_array[popped_idx] &lt; self.heap_array[right_child_popped_idx]: self.heap_array[popped_idx], self.heap_array[right_child_popped_idx] = self.heap_array[right_child_popped_idx], self.heap_array[popped_idx] popped_idx = right_child_popped_idx return returned_data def move_up(self, inserted_idx): if inserted_idx &lt;= 1: return False parent_idx = inserted_idx // 2 if self.heap_array[inserted_idx] &gt; self.heap_array[parent_idx]: return True else: return False def insert(self, data): if len(self.heap_array) == 1: self.heap_array.append(data) return True self.heap_array.append(data) inserted_idx = len(self.heap_array) - 1 while self.move_up(inserted_idx): parent_idx = inserted_idx // 2 self.heap_array[inserted_idx], self.heap_array[parent_idx] = self.heap_array[parent_idx], self.heap_array[inserted_idx] inserted_idx = parent_idx return True 힙을 파이썬으로 구현 힙의 연산의 시간 복잡도 정리 힙 연산 시간 복잡도 make-heap O(nlogn) find-max O(1) insert O(logn) delete-max O(logn) 리프 레벨까지 도달 O(logn) Search를 효율적으로 할 수 있는 자료구조가 아니기 때문에 굳이 구현하지 않음 가장 큰(작은) 값을 찾거나 지우는 연산이 많은 곳에 효율적 참고 잔재미코딩 신찬수 교수님 유튜브 위키 백과 Heee’s Development Blog",
    "tags": "datastructure computerscience",
    "url": "/computerscience/2021/07/07/cs_ds_01/"
  },{
    "title": "Tree",
    "text": "Tree 트리 일반적으로 대상 정보의 각 항목들을 계층적으로 연관되도록 구조화시키고자 할 때 사용하는 비선형 자료구조 Node와 Branch를 이용해서, 사이클을 이루지 않도록 구성한 데이터 구조 한 개의 루트 노드만이 존재하며, 모든 자식 노드는 한 개의 부모 노드만을 가짐 (즉, 루트에서 어떤 노드로 가는 경로는 유일) 보통 이진 트리(Binary Tree) 형태의 구조로, 탐색(검색) 알고리즘 구현을 위해 많이 사용됨 트리 관련 용어 노드 (Node) : 트리에서 데이터를 저장하는 기본 요소 (데이터와 다른 연결된 노드에 대한 Branch 정보 포함) 간선 (Branch) : 노드를 연결하는 선 (edge, link라고도 부름) 내부 노드 (Internal Node) : 말단 노드가 아닌 노드 루트 노드 (Root Node) : 트리 맨 위에 있는 노드 말단 노드 (Leaf Node) : 자식 노드가 하나도 없는 노드 (단말 노드, 잎 노드) 부모 노드 (Parent Node) : 어떤 노드의 다음 레벨에 연결된 노드 자식 노드 (Child Node) : 어떤 노드의 하위 레벨에 연결된 노드 형제 노드 (Brother Node) : 동일한 부모 노드를 가진 노드 (Sibling) 노드의 레벨 (Level): 최상위 노드를 Level 0으로 하였을 때, 하위 Branch로 연결된 노드의 깊이를 나타냄 노드의 크기 (Size) : 자신을 포함한 모든 자손 노드의 개수 노드의 깊이 (Depth) : 트리에서 노드가 가질 수 있는 최대 레벨 노드의 높이 (height) : 루트 노드에서 가장 깊숙히 있는 노드의 깊이 출처 : https://www.fun-coding.org/Chapter10-tree.html 트리 관련 용어 정리 트리의 종류 이진 트리 (Binary Tree) : 노드의 최대 Branch가 2인 트리 완전 이진 트리 (Complete Binary Tree) : 노드를 삽입할 때 왼쪽부터 차례대로 추가하는 이진 트리 전 이진 트리 (Full Binary Tree) : 모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리 포화 이진 트리 (Perfect Binary Tree) : 모든 내부 노드가 두 개의 자식 노드를 가지며 모든 잎 노드가 동일한 깊이 또는 레벨을 갖는 트리 편향 트리 (Skewed Tree) : 한쪽으로 기울어진 트리, 사향 트리라고도 부름 출처 : https://velog.io/@adam2/TREE 이진 트리의 종류 이진 탐색 트리 (Binary Search Tree, BST) 왼쪽 노드는 해당 노드보다 작거나 같은 값, 오른쪽 노드는 해당 노드보다 큰 값을 가지는 추가적인 조건이 있는 이진 트리 출처 : https://www.mathwarehouse.com/programming/gifs/binary-search-tree.php#binary-search-tree-insertion-node 이진 탐색 트리 이진 탐색 트리의 시간 복잡도 트리의 높이를 h라고 표현 한다면, O(h)의 시간 복잡도를 가짐 n개의 노드를 가진다면, h = logn에 가까우므로 시간 복잡도는 O(logn) 장점 기존의 O(n)의 탐색 속도를 O(logn)으로 개선할 수 있음 출처 : https://www.mathwarehouse.com/programming/gifs/binary-search-tree.php#binary-search-tree-insertion-node 이진 탐색 트리와 정렬된 배열간의 탐색 속도 비교 단점 균형이 잡혀 있을 때 기준 시간복잡도는 O(logn)이지만 편향 트리에서는 링크드 리스트등과 동일한 성능을 보여줄 수도 있음 이를 해결하기 위해 균형 이진 탐색 트리를 활용 함 출처 : https://www.fun-coding.org/Chapter10-tree.html 편향 트리 # 노드 클래스 만들기 class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self, head): self.head = head # 데이터 삽입 def insert(self, value): self.current_node = self.head while True: if value &lt; self.current_node.value: if self.current_node.left != None: self.current_node = self.current_node.left else: self.current_node.left = Node(value) break else: if self.current_node.right != None: self.current_node = self.current_node.right else: self.current_node.right = Node(value) break # 데이터 탐색 def search(self, value): self.current_node = self.head while self.current_node: if self.current_node.value == value: return True elif value &lt; self.current_node.value: self.current_node = self.current_node.left else: self.current_node = self.current_node.right return False #데이터 삭제 def delete(self, value): # 삭제할 노드 탐색 searched = False self.current_node = self.head self.parent = self.head while self.current_node: if self.current_node.value == value: searched = True break elif value &lt; self.current_node.value: self.parent = self.current_node self.current_node = self.current_node.left else: self.parent = self.current_node self.current_node = self.current_node.right if searched == False: return False # case1 : 삭제할 노드가 Leaf Node일 경우 if self.current_node.left == None and self.current_node.right == None: if value &lt; self.parent.value: self.parent.left = None else: self.parent.right = None # case2 : 삭제할 노드가 Child Node를 한 개 가지고 있을 경우 elif self.current_node.left != None and self.current_node.right == None: if value &lt; self.parent.value: self.parent.left = self.current_node.left else: self.parent.right = self.current_node.left elif self.current_node.left == None and self.current_node.right != None: if value &lt; self.parent.value: self.parent.left = self.current_node.right else: self.parent.right = self.current_node.right # case 3 - 삭제할 노드가 Child Node를 두개 가지고 있을 경우 elif self.current_node.left != None and self.current_node.right != None: # case3-1 : 삭제할 Node가 Parent Node 왼쪽에 있을 때 if value &lt; self.parent.value: self.change_node = self.current_node.right self.change_node_parent = self.current_node.right while self.change_node.left != None: self.change_node_parent = self.change_node self.change_node = self.change_node.left if self.change_node.right != None: self.change_node_parent.left = self.change_node.right else: self.change_node_parent.left = None self.parent.left = self.change_node self.change_node.right = self.current_node.right self.change_node.left = self.change_node.left # case 3-2 : 삭제할 Node가 Parent Node 오른쪽에 있을 때 else: self.change_node = self.current_node.right self.change_node_parent = self.current_node.right while self.change_node.left != None: self.change_node_parent = self.change_node self.change_node = self.change_node.left if self.change_node.right != None: self.change_node_parent.left = self.change_node.right else: self.change_node_parent.left = None self.parent.right = self.change_node self.change_node.right = self.current_node.right self.change_node.left = self.current_node.left return True 이진 탐색 트리를 파이썬으로 구현 균형 이진 탐색 트리 (Balanced BST) 평균적으로 O(logn)의 연산 속도를 가진 이진 검색 트리가 편향 트리가 되었을 때 O(n)의 연산 속도를 가지는 것을 방지하기 위해 만들어진 자료구조 Red-Black 트리 아래 5가지 조건을 가지는 이진 탐색 트리 트리의 모든 노드는 Red or Black으로만 구성되어 있음 루트 노드는 무조건 Black 모든 리프 노드는 무조건 Black 루트 노드에서 리프 노드까지 Black의 갯수는 항상 같음 Red 노드의 자식은 모두 Black (Black 노드의 자식은 상관 없음) 자바에서는 treeSet, treeMap이 Red-Black 트리를 구현함 5번 조건으로 인해 Red는 중복될 수 없으니 Red와 Red 사이엔 하나의 블랙 노드를 끼게 되고, 이는 곧 Red-Black 트리의 총 깊이가 됨 결국 블랙 노드만을 가지는 가장 짧은 깊이와 Red-Black의 차이는 무조건 2배 이하의 길이 차이가 남 AVL 트리 모든 노드에 대해서 노드의 왼쪽부 트리와 오른쪽부 트리의 높이 차가 1 이하로 맞춘 이진 탐색 트리 -1, 0, 1로 이루어진 Balance Factor를 기준으로 Rotation이 이루어져 균형을 맞춤 Red-Black vs AVL 더 엄격한 균형을 유지하고 있는 AVL이 Red-Black보다 더 빠른 Search 속도를 제공 더 느슨한 균형을 유지하고 있는 Red-Black이 AVL보다 더 빠른 Insert와 Delete 속도를 제공 Red-Black은 대부분의 언어 라이브러리에서 자주 사용 AVL은 조회에 자주 사용되는 Database에 자주 사용 참고 잔재미코딩 신찬수 교수님 유튜브 위키 백과",
    "tags": "datastructure computerscience",
    "url": "/computerscience/2021/07/02/cs_ds_01/"
  },{
    "title": "[프로그래머스 / lv.1] 비밀지도",
    "text": "날짜: 2021년 6월 29일 소요 시간: 32분 53초 카테고리: 수학문제 태그: 레벨1, 파이썬 코딩테스트 연습 - 비밀지도 입출력 예시 매개변수 값 n 5 arr1 [9, 20, 28, 18, 11] arr2 [30, 1, 21, 17, 28] 출력 [”#####”,”# # #”, “### #”, “# ##”, “#####”] 매개변수 값 n 6 arr1 [46, 33, 33 ,22, 31, 50] arr2 [27 ,56, 19, 14, 14, 10] 출력 [”######”, “### #”, “## ##”, “ #### “, “ #####”, “### # “] 내가 적은 코드 def solution(n, arr1, arr2): answer = [] map2 = [[0 for col in range(n)] for row in range(n)] map1 = [[0 for col in range(n)] for row in range(n)] for i in range(n): map1[i] = [j for j in str(format(arr1[i],'b').zfill(n))] for i in range(n): map2[i] = [j for j in str(format(arr2[i],'b').zfill(n))] for i in range(n): str_answer = '' for j in range(n): if map1[i][j] == '1' or map2[i][j] == '1': str_answer += '#' else: str_answer += ' ' answer.append(str_answer) return answer 풀이 과정 map1과 map2에 n x n 의 정사각형 2차원 행렬을 만들어 놓는다. (사실 이렇게까지 할 필요 없었다.) 그리고 10진법으로 표현 된 arr1,arr2의 원소들을 n자리 수까지의 2진수로 변환한 후 각각 map1과 map2에 저장한다. 그리고 map1[i][j]와 map2[i][j]이 둘 중 하나만이라도 1이라면 #을 추가하고 둘다 0이라면 공백을 추가한다. 그렇게 만들어진 문자열 str_answer을 리스트 answer에 저장한다. 베스트 코드 def solution(n, arr1, arr2): answer = [] for i,j in zip(arr1,arr2): a12 = str(bin(i|j)[2:]) a12=a12.rjust(n,'0') a12=a12.replace('1','#') a12=a12.replace('0',' ') answer.append(a12) return answer 반성 파이썬의 다양한 기본 내장 함수들만 제대로 알아도 코드가 훨씬 간결하고 깔끔 해 질 수 있는 문제였는데, 너무 곧이곧대로 문제만 풀었다. 역시 다양한 문제를 풀어가면서 다양한 파이썬 함수들을 알아가야겠다. 내가 베스트 코드 보면서 느낀 감정.png",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/06/29/ap_pg_post1/"
  },{
    "title": "[백준 / 1342] 행운의 문자열",
    "text": "날짜: 2021년 6월 25일 소요 시간: 2시간 초과 카테고리: 문자열, 브루트포스 알고리즘, 백트래킹 태그: gold.5, 1342, 파이썬, time out 백준 1342 - 행운의 문자열 입출력 예시 예제 입력 예제 출력 aabbbaa 1 내가 적은 코드 import sys num = str(sys.stdin.readline().strip()) dic = dict() def solution(pre_word, word): if word == len(num): return 1 answer = 0 for key in dic.keys(): if pre_word == key: #이전 문자와 중복될 때 continue if dic[key] == 0: #더이상 문자가 남아있지 않을 때 continue dic[key] -= 1 answer += solution(key, word+1) dic[key] += 1 return answer for i in list(set(num)): dic[i] = num.count(i) answer = solution('', 0) print(answer) 풀이 과정 2시간가량 문제의 접근법조차 감을 잡지 못하고 있다가 구글링해서 나온 유일하게 파이썬으로 구현한 코드를 보며 간신히 풀었다. 해설을 보고도 이해가 잘 되지 않아서 한참을 쳐다보고 있었다. 재귀 함수를 활용해서 pre_word가 아닌 문자가 들어왔을 때 함수를 재귀하는 방식으로 문자열이 완성되었을 때 그 문자는 행운의 문자열임으로 word를 증가시키는 방식 이 방식 마저도 Python3으로 실행 시 시간초과가 나서 PyPy3로 실행해서 간신히 성공하였다. Python3과 PyPy3의 실행 속도 차이의 이유는 여기를 참조하면 좋을 것 같다. 베스트 코드 s=input() lens=len(s) d={} answer=[] count=0 notonly=[] import math def ncr(n,r): f = math.factorial return f(n) / f(r) / f(n-r) for l in s: if l in d: if d[l]==1: notonly.append(l) d[l]+=1 else: d[l]=1 def next(s,d,notonly): global count global answer global lens for l,n in d.items(): no=list(notonly) if n==0: continue k=dict(d) if len(no)==1: only=0 for i in d.values(): if i==1: only+=1 if only==0: return if s=='': if k[notonly[0]]&gt;only+1: return count+=math.factorial(only)*ncr(only+1,k[notonly[0]]) return elif s[-1]==notonly[0]: if only&gt;k[notonly[0]]: return p=math.factorial(only) count+=p*ncr(only,k[notonly[0]]) else: if only+1&lt;k[notonly[0]]: return count+=(only-1)*math.factorial(only-1)*ncr(only+1,k[notonly[0]])+math.factorial(only-1)*(ncr(only,k[notonly[0]]-1) if k[notonly[0]]&gt;1 else 1) return elif len(no)==0: only=0 for i in k.values(): if i==1: only+=1 count+=math.factorial(only) return if not s=='' and s[-1]==l: continue k[l]-=1 if k[l]==1: no.remove(l) if k[l]&gt;((lens-len(s)-1)/2): continue next(s+l,k,no) if len(s)==lens: count+=1 next('',d,notonly) print(int(count)) 반성 베스트 코드로 풀었을 때 Python3으로 실행했음에도 PyPy3로 실행한 내 코드보다 무려 3배나 더 빨랐다. 하지만 베스트 코드를 아무리 봐도 도저히 이해가 잘 가지 않는다…. 혹시나 지나가다 이 포스팅과 저 코드를 본 개발자님들이 계신다면 코드 리뷰 댓글로 부탁드리겠습니다…ㅠ",
    "tags": "baekjoon algorithmpractice",
    "url": "/algorithmpractice/2021/06/25/ap_bj_post1/"
  },{
    "title": "Hash Table",
    "text": "Hash Table 해시 테이블 키(Key)에 데이터(Value)를 저장하는 데이터 구조 Key를 통해 바로 데이터를 받아올 수 있으므로, 속도가 획기적으로 빨라짐 보통 배열로 미리 Hash Table 사이즈만큼 생성 후에 사용 (공간과 탐색 시간을 맞바꾸는 기법) 캐쉬를 구현하는 등의 검색, 저장, 삭제, 읽기가 많이 필요한 경우 사용 파이썬에서는 dictionary 타입으로 해시 테이블을 구현 가능 순차적으로 배열에 저장되어있는 자료를 삽입, 삭제, 탐색을 할 때는 일반적으로 시간복잡도가 O(n)이 되는데 해시 테이블로 자료를 저장한다면 일반적으로 삽입, 삭제, 탐색에 상수 시간 O(1) 밖에 걸리지 않음 (모든 경우에 충돌이 발생하는 최악의 경우 O(n)의 시간 복잡도가 듦) 장점 데이터 저장/읽기 속도가 빠름 (검색 속도가 빠름) 해시는 키에 대한 데이터가 있는지(중복) 확인이 쉬움 단점 연결을 위한 별도 데이터 공간이 필요하므로 저장 공간 효율이 높지 않음 데이터를 찾는 시간이 필요하므로 접근 속도가 느림 중간 데이터 삭제 시, 앞뒤 데이터의 연결을 재구성해야 하는 부가적인 작업 필요 순서와 상관없이 key만을 가지고 hash를 찾아 저장하기 때문에 상하관계가 있거나, 순서가 중요한 데이터의 경우 Hash Table은 어울리지 않음 (파이썬 3.7 부터 표준 딕셔너리 dict 가 삽입 순서를 보존) 해시 관련 용어 해시(Hash): 임의 값을 고정 길이로 변환하는 것 해시 테이블(Hash Table): 키 값의 연산에 의해 직접 접근이 가능한 데이터 구조 해싱 함수(Hashing Function): Key에 대해 산술 연산을 이용해 데이터 위치를 찾을 수 있는 함수 해시 값(Hash Value) 또는 해시 주소(Hash Address): Key를 해싱 함수로 연산해서, 해시 값을 알아내고, 이를 기반으로 해시 테이블에서 해당 Key에 대한 데이터 위치를 일관성있게 찾을 수 있음 슬롯(Slot): 한 개의 데이터를 저장할 수 있는 공간 출처 : https://www.fun-coding.org/DS&amp;AL1-6.html 일반적인 해시 테이블의 프로세스 충돌 (Hash collision) 충돌 해결 함수 (collision resolution method)를 통해서 충돌을 해결 해시 테이블을 구성함에 있어서 고려해야 할 사항 table (list) Hash function Hash collision resolution method 해시 함수 (Hash function) Division hash function 나머지 연산으로 key 값을 정하는 해시 함수 Perfect hash function 충돌이 일어나지 않고 1 to 1 으로 각각 다른 슬롯에 자료가 저장될 수 있게끔 하는 해시 함수 이상적인 해시 함수 (비현실적) Universial hash function 두개의 서로 다른 키 값이 같은 슬롯에 저장 될 확률이 해시 테이블 사이즈에 반비례하는 함수 그 외에도 Multiplication, Folding, Mid squares, Extraction와 key 값이 string일 때의 Additive, Rotating 등 다양한 해시 함수들이 있다. 해시 테이블의 평균 데이터 처리의 시간 복잡도는 O(1)이지만, 이는 해시 함수의 연산을 고려하지 않는 결과 해시 함수가 매우 복잡하다면 해시테이블의 모든 연산의 시간 효율성은 증가 -&gt; 해시 함수의 선택도 중요 충돌 회피 함수 (Hash collision resolution method) open addressing linear probing 폐쇄 해싱 또는 Close Hashing 기법 중 하나: 해쉬 테이블 저장공간 안에서 충돌 문제를 해결하는 기법 충돌이 일어나면, 해당 hash address의 다음 address부터 맨 처음 나오는 빈공간에 저장하는 기법 저장공간 활용도를 높이기 위한 기법 linear probing으로 충돌을 회피할 때 클러스터(저장된 자료가 모여있는 군집)가 적어야 시간 복잡도가 줄어듦 quadratic probing k -&gt; k + 1^2 -&gt; k + 2^2 -&gt; k + 3^2 -&gt; … double hashing 해시 함수를 두개 사용하는 기법 f(key) -&gt; f(key) + g(key) -&gt; f(key) + 2g(key) -&gt; f(key) + 3g(key) -&gt; … 장점 또 다른 저장공간 없이 해시테이블 내에서 데이터 저장 및 처리가 가능 또 다른 저장공간에서의 추가적인 작업이 없음 단점 해시 함수(Hash Function)의 성능에 전체 해시테이블의 성능이 결정됨 데이터의 길이가 늘어나면 그에 해당하는 저장소를 마련해 두어야 함 출처 : https://www.geeksforgeeks.org/ linear probing 예시 chaining 개방 해싱 또는 Open Hashing 기법 중 하나: 해시 테이블 저장공간 외의 공간을 활용하는 기법 충돌이 일어나면, 링크드 리스트라는 자료 구조를 사용해서, 링크드 리스트로 데이터를 추가로 뒤에 연결시켜서 저장하는 기법 장점 한정된 저장소(Bucket)을 효율적으로 사용 가능 해시 함수(Hash Function)을 선택하는 중요성이 상대적으로 적음 상대적으로 적은 메모리를 사용하여 미리 공간을 잡아 놓을 필요가 없음 단점 한 Hash에 자료들이 계속 연결된다면(쏠림 현상) 검색 효율을 낮출 수 있음 외부 저장 공간을 사용하여 외부 저장 공간 작업을 추가로 해야 함 출처 : https://velog.io/@cyranocoding/ chaining 예시 class HashTable: def __init__(self): self.hash_table = list([0 for i in range(8)]) def get_key(self): return hash(self) def hash_function(self, key): return key % 8 def insert(self, key, value): hash_value = self.hash_function(get_key(data)) self.hash_table[hash_value] = value def read(self, key): hash_value = self.hash_function(get_key(key)) return self.hash_table[hash_value] def print(self): print(self.hash_table) 해시 테이블을 파이썬으로 구현 삽입 삭제 탐색 연산은 cluster size에 영향을 받음 cluster size는 해시 함수, 충돌 해결 함수, 로드 팩터의 영향을 받음 (로드 팩터 : (테이블에 저장된 아이템의 갯수) / (슬롯의 갯수)) 로드 팩터와 충돌 비율을 통해서 해시 테이블에 관련된 연산들의 수행시간, 성능 등을 평가 가능 클러스터의 빈 슬롯이 평균적으로 50% 이상을 유지한다면 해시 테이블의 연산의 시간 복잡도가 평균 O(1)으로 수렴 참고 잔재미코딩 신찬수 교수님 유튜브",
    "tags": "datastructure computerscience",
    "url": "/computerscience/2021/06/23/cs_ds_01/"
  },{
    "title": "[프로그래머스 / lv.1] 실패율",
    "text": "날짜: 2021년 6월 21일 소요 시간: 39분 58초 카테고리: 수학문제 태그: 레벨1, 파이썬 코딩테스트 연습 - 실패율 입출력 예시 N stages result 5 [2,1,2,6,2,4,3,3] [3,4,2,1,5] 4 [4,4,4,4,4] [4,1,2,3] 내가 적은 코드 def solution(N, stages): answer = [] fail_rate = [] for i in range(N): success = 0 for j in stages: if j-1 &gt;= i: success += 1 if success != 0: fail_rate.append(float(stages.count(i+1))/float(success)) else: fail_rate.append(0) temp = sorted(fail_rate, reverse = True) for k in range(len(fail_rate)): answer.append(fail_rate.index(temp[k])+1) fail_rate[fail_rate.index(temp[k])] = \"\" return answer 풀이 과정 전체 스테이지의 수 N만큼 반복하는 반복문을 만든다. stages의 원소들에 1을 뺀 값(range(N)은 0부터 N까지 / stage는 1부터 N+1까지)을 반복하여 N보다 클 경우 success에 1씩 더하여 카운팅한다. 분모(success)가 0이 되면 안되기 때문에 조건을 추가하고, 실패율을 계산하여 리스트 fail_rate에 순서대로 담는다. 리스트 temp에 오름차순으로 정리 한 fail_rate의 값들을 담는다. fail_rate의 길이만큼 반복하여 실패율이 높은 값부터 정렬되어 있는 temp의 인덱스 값을 가진 fail_rate 원소의 인덱스 값에 1을 더한 값(배열의 인덱스 값은 0부터 시작하고, 스테이지는 1부터 시작하기 때문)을 리스트 answer에 추가한다. -&gt; 그러니까 실패율이 높은 순으로 정리한 리스트 temp의 원소의 인덱스 값을 리스트 fail_rate에서 인덱싱하여 그 값을 answer에 추가하면 실패율이 높은 스테이지 순으로 추가된다. (중복 방지를 위해 한번 꺼낸 temp의 인덱스에는 빈 값을 삽입한다.) 실패율이 높은 순으로 정리된 스테이지 값이 들어가 있는 리스트 answer을 출력한다. 베스트 코드 def solution(N, stages): result = {} denominator = len(stages) for stage in range(1, N+1): if denominator != 0: count = stages.count(stage) result[stage] = count / denominator denominator -= count else: result[stage] = 0 return sorted(result, key=lambda x : result[x], reverse=True) 반성 파이썬의 딕셔너리를 통해 더 간결하게 풀 수 있다는 것을 인지하고 있었으나 딕셔너리의 이해도가 낮아 제대로 활용할 수 없을 것 같아 딕셔너리로 풀지 못하였다. 파이썬을 좀더 자유자재로 활용할 수 있도록 이해도를 높일 필요가 있다. 리스트의 원소를 인덱싱한 값을 또 sorting된 다른 리스트에 인덱싱하여 그 인덱스 값을 다른 리스트에 저장하는 건 내가 풀었지만 포스팅을 위해 다시 생각해도 또 헷갈리고 그런다…",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/06/21/ap_pg_post1/"
  },{
    "title": "[백준 / 4949] 균형잡힌 세상",
    "text": "날짜: 2021년 6월 21일 소요 시간: 1시간 12분 49초 카테고리: 스택, 문자열, 수학문제 태그: silver.4, 4949, 파이썬 백준 4949 - 균형잡힌 세상 입출력 예시 예제 입력 예제 출력 So when I die (the [first] I will see in (heaven) is a score list). yes [ first in ] ( first out ). yes Half Moon tonight (At least it is better than no Moon at all]. no A rope may form )( a trail in a maze. no Help( I[m being held prisoner in a fortune cookie factory)]. no ([ (([( [ ] ) ( ) (( ))] )) ]). yes . yes .   내가 적은 코드 import sys class Stack: def __init__(self): self.items = [] def push(self, val): self.items.append(val) def pop(self): if self.isEmpty(): print(\"stack is empty\") else: return self.items.pop() def top(self): if not self.isEmpty(): return self.items[-1] def __len__(self): return len(self.items) def isEmpty(self): is_empty = False if len(self.items) == 0: is_empty = True return is_empty arr = [] while True: line = sys.stdin.readline().rstrip() if line == '.': break else: arr.append(line) stack = Stack() for j in arr: stack = Stack() for i in str(j): if i == \"[\" or i == \"(\": stack.push(i) elif i == \"]\": if stack.top() == \"[\": stack.pop() else: print(\"no\") break elif i == \")\": if stack.top() == \"(\": stack.pop() else: print(\"no\") break elif i == \".\": if stack.isEmpty(): print(\"yes\") else: print(\"no\") 풀이 과정 분명 더 짧게 풀 수 있지만 이번 기회에 스택을 실제로 구현해 보는 연습을 하기 위해 클래스로 스택을 구현해놓고 문제를 풀었다. Stack클래스로 스택을 구현하고 문제를 접근했다. 여러 줄이 입력될 경우도 있다고 하였으니, 문자열을 line에 저장하고 그 line을 arr에 저장한다. 입력의 종료 조건인 .이 나올 때 까지 문자열을 arr에 저장한다. 그리고 문자열을 반복문을 통해 괄호가 열리는 (나 [가 나올 때 까지 문자들을 검사한다. 그리고 괄호가 닫히는 (나 [가 나올 시 stack에 push한다. 만약 stack의 top에 있는 괄호의 종류와 검사한 괄호의 종류가 맞지 않거나 stack이 비어있는데 닫히는 괄호가 나올 시 “no”를 출력하고 반복을 break 한다. 만약 괄호가 닫히는 )나 ]가 나올 시 stack의 top이 (나 [인지 확인하고 같은 종류의 괄호라면 pop하게 끔 만들었다. 그리고 문자열의 마지막을 알리는 .이 나온다면 isEmpty()함수를 통해 stack이 비어있는지 확인 후 비어있다면 “yes”를 아니라면 “no”를 출력한다. 베스트 코드 from sys import stdin, stdout def isvalid(s): stack = [] for c in s: if c in '([': stack.append(c) elif c == ')': if not stack or stack.pop() != '(': return False elif c == ']': if not stack or stack.pop() != '[': return False return not stack strings = stdin.readlines() strings.pop() for string in strings: stdout.write(\"yes\\n\" if isvalid(string) else \"no\\n\") 반성 스택에 대해서 이론적으로 이해하고 있다고 생각해서 크게 신경쓰지 않았는데 막상 코드로 구현하려고 했을 때 오류가 많이 나서 버벅였다. 앞으로 다른 자료구조를 공부해도 보다 확실히 체득할 때 까지 코드로 구현해 볼 필요가 있다.",
    "tags": "baekjoon algorithmpractice",
    "url": "/algorithmpractice/2021/06/21/ap_bj_post1/"
  },{
    "title": "[백준 / 1157] 단어 공부",
    "text": "날짜: 2021년 6월 17일 소요 시간: 37분 21초 카테고리: 수학문제 태그: bronze.1, 1157, 파이썬 백준 1157 - 단어 공부 입출력 예시 예제 입력 예제 출력 Mississipi ? zZa Z z Z baaa A 내가 적은 코드 word = input().upper() arr = list(set(word)) answer = [] for i in arr: answer.append(word.count(i)) if answer.count(max(answer)) &gt;= 2: print(\"?\") else: print(arr[(answer.index(max(answer)))]) 풀이 과정 word에 문자열을 저장한 뒤 upper()함수로 모두 대문자로 바꾸어 주고, arr에 문자열에서 중복을 제외한 원소들을 저장한다. 그리고 arr의 원소를 차례대로 word 문자열의 원소들의 개수를 count()함수로 카운팅해서 answer리스트에 저장한다. 만약 answer의 리스트에서 최댓값의 갯수가 2개 이상일 때 (=가장 많이 사용 된 알파벳이 여러개일 때) ?를 출력한다. 그 answer의 최댓값 (=가장 많이 사용된 알파벳의 갯수)의 인덱스를 arr에서 인덱싱해서 (=가장 많이 사용된 알파벳) 출력한다. 베스트 코드 s,a=input().lower(),[] for i in range(97,123): a.append(s.count(chr(i))) print('?'if a.count(max(a))&gt;1 else chr(a.index(max(a))+97).upper()) 반성 문자열과 리스트의 개념을 확실히 알고 있어서 인덱싱에 대한 이해도가 높아야 풀 수 있는 문제였다. 조금 삐걱거리긴 했어도 베스트 코드와 비슷한 로직으로 문제를 풀었단 점에 뿌듯했다.",
    "tags": "baekjoon algorithmpractice",
    "url": "/algorithmpractice/2021/06/17/ap_bj_post1/"
  },{
    "title": "[백준 / 4673] 셀프 넘버",
    "text": "날짜: 2021년 6월 15일 소요 시간: 1시간 26분 34초 카테고리: 수학문제 태그: silver.5, 4673, 파이썬 백준 4673 - 셀프 넘버 입출력 예시 예제 출력   1   3   5   7   a lot more numbers   9971   9982   9993   내가 적은 코드 arr = set(range(1, 10000)) del_arr = set() for num in arr: for i in str(num): num += int(i) del_arr.add(num) answer = sorted(arr - del_arr) print(\"\\n\".join(map(str, answer))) 풀이 과정 arr에 10000까지 저장하고 del_arr에 생성자가 존재하는 수를 저장한 뒤, set함수를 통해 answer에 arr에서 del_arr을 제외하는 방식으로 셀프 넘버의 배열을 구하는 방식으로 풀었다. 베스트 코드 def self_num(x): a = int(x) if a &gt; 10000: return else: for j in range(len(x)): a += int(x[j]) if a &gt; 10000: return check[a] = True self_num(str(a)) check = [False]*10001 for i in range(1, 10000): self_num(str(i)) for i in range(1, 10000): if check[i] ==False: print(i) 반성 이제 브론즈 문제는 쉽게 풀겠는데 실버 문제에 대해서는 아직 시간이 너무 오래걸리는 것 같다. 실버 문제 또한 30분 안에 풀 정도로 알고리즘 문제에 익숙해 질 필요가 있다. 재귀 함수로 풀고 싶었으나 재귀 함수에 이해도가 낮아서 포기하고 다른 방식으로 풀었다. 다양한 방식으로 문제를 풀 수 있을 정도로 문제를 많이 풀어봐야겠다. 재귀 함수로 풀고 싶어서 베스트 코드로 재귀함수를 들고 오긴 했으나 아이러니하게도 재귀 함수로 풀면 시간이 45배 정도 더 걸린다. 사실 베스트 코드는 아닌걸로…",
    "tags": "baekjoon algorithmpractice",
    "url": "/algorithmpractice/2021/06/15/ap_bj_post1/"
  },{
    "title": "[백준 / 4344] 평균은 넘겠지",
    "text": "날짜: 2021년 6월 14일 소요 시간: 50분 26초 카테고리: 수학문제 태그: bronze.1, 4344, 파이썬 백준 4344 - 평균은 넘겠지 입출력 예시 예제 입력 예제 출력 5   5 50 50 70 80 100 40.000% 7 100 95 90 80 70 60 50 57.143% 3 70 90 80 33.333% 3 70 90 81 66.667% 9 100 99 98 97 96 95 94 93 91 55.556% 내가 적은 코드 import sys N = int(input()) for i in range(N): count = 0 n = list(map(int, sys.stdin.readline().split())) avg = (sum(n)-n[0])/n[0] for j in n[1:]: if j &gt; avg: count += 1 answer = count/n[0]*100 print(f\"{answer:.3f}%\") 풀이 과정 map을 활용해서 n리스트에 성적 값을 입력하고, 리스트 슬라이싱을 통해 평균값을 구한다. 구한 평균값을 기준으로 평균보다 높은 점수가 몇 개가 있는지 반복문을 통해 count에 저장하고, answer에 그 비율을 저장한다. 마지막에 answer을 float형으로 소수점 셋째자리까지 f-string을 통해 출력 왜 정답률이 40%가 되지않는지 의아할 정도로 쉬운 문제이지만 자료형에 대한 이해도가 낮으면 계속 오류가 날 수도 있겠다는 생각을 했다. 물론 나 또한 그거 때문에 한참을 헤매었다. 베스트 코드 n = int(input()) a=list(map(int, input().split())) m = max(a) for i in range(n): a[i] = a[i]/m*100 print(sum(a)/n) 반성 변수 N의 타입을 파이참에서는 자동으로 정수형으로 지정 해 주었으나 백준 인터프리터에서는 문자열로 받았던지 뭔진 모르겠지만 파이참에서는 잘 실행되는 코드가 왜 백준에서는 TypeError가 나는지 계속 못찾아서 한참을 헤매었다. 타입 선언을 확실하게 잡아야 된다…",
    "tags": "baekjoon algorithmpractice",
    "url": "/algorithmpractice/2021/06/14/ap_bj_post1/"
  },{
    "title": "[백준 / 1546] 평균",
    "text": "날짜: 2021년 6월 13일 소요 시간: 19분 27초 카테고리: 수학문제 태그: bronze.1, 1546, 파이썬 백준 1546 - 평균 입출력 예시 예제 입력 예제 출력 3   40 80 60 75.0 5   1 2 4 8 16 38.75 2   3 10 65.0 내가 적은 코드 import sys n = input() new = [] num = list(map(float, sys.stdin.readline().split())) for i in range(0,len(num)): new.append(num[i]/max(num)*100) print(sum(new)/len(new)) 풀이 과정 입력된 값을 num에 float값으로 저장한 뒤 (평균값의 소수점까지 연산하기 위해) 반복문을 통해서 각 원소의 연산을 진행한다. 그 후 원소의 각 연산된 값을 new에 저장 한 뒤 평균값을 구하기 위해 new의 원소의 합을 그 원소의 길이만큼 나눈다. 베스트 코드 n = int(input()) a=list(map(int, input().split())) m = max(a) for i in range(n): a[i] = a[i]/m*100 print(sum(a)/n) 반성 map의 타입과 list의 타입의 개념을 확실히 잡지 못해서 런타임를 내고 시간을 많이 잡아 먹었다. input() 보다 sys.stdin.readline()을 활용하는 연습을 더 많이 해야겠다.",
    "tags": "baekjoon algorithmpractice",
    "url": "/algorithmpractice/2021/06/13/ap_bj_post1/"
  },{
    "title": "[백준 / 1158] 더하기 사이클",
    "text": "날짜: 2021년 6월 12일 소요 시간: 34분 17초 카테고리: 수학문제 태그: bronze.1, 1110 , 파이썬 백준 1110 - 더하기 사이클 입출력 예시 예제 입력 예제 출력 26 4 55 3 1 60 0 1 내가 적은 코드 num = int(input()) check = num new_num = 0 temp = 0 count = 0 while True: temp = num//10 + num%10 new_num = (num%10)*10 + temp%10 count += 1 num = new_num if new_num == check: break print(count) 풀이 과정 새로 만들어진 숫자 new_num이 처음 입력된 숫자인 check와 같아질 때까지 while문을 반복한다. temp에 10의 자리 숫자와 1의 자리 숫자를 더한 수를 저장하고 그 수로 새로운 수를 만들어 new_num에 저장한다. 그리고 num을 new_num으로 바꾼다. 이 과정을 반복하여 new_num이 check와 같아질 때까지 돈 사이클의 횟수를 count에 저장하고 출력한다. 베스트 코드 N = int(input()) n = -1 t = 0 while n != N: if n == -1: n = N n = (n//10 + n%10)%10 + (n%10)*10 t += 1 print(t) 반성 숫자를 10으로 나눈 나머지와, 10으로 나눈 몫을 활용하면 (입력은 99이하의 자연수) 쉬운 걸 처음에 문자열로 변환하여 슬라이싱한 후에 다시 정수형으로 변환하여 계산한다고 자료형 왔다갔다 하는 데 헷갈려서 시간이 많이 지났다.",
    "tags": "baekjoon algorithmpractice",
    "url": "/algorithmpractice/2021/06/12/ap_bj_post1/"
  },{
    "title": "210610 Essay",
    "text": "들어가며 이 블로그를 만든 지 한 달 만에 처음 에세이를 써 본다. 새벽에 일기 쓰듯 글을 쓰는 것을 좋아하는 편이긴 한데, 요즘 피곤하다는 핑계로 이리 미루고 저리 미루다가 결국 한달이나 되어서야 처음 글을 쓴다. 어찌 되었던 블로그에 게시하는 첫 에세이다보니 나에 대해 길지는 않지만, 짧지도 않게 한번 소개를 해 보려 한다. 이 글 자체가 자기 만족일 수도 있다. 지금 내 블로그에 들어오는 방문자 유입 수를 보면 이 글은 정말 잘 도달 해 봐야 10명 정도에게 노출 될 것이며, 그 중 이 글을 다 읽는 사람은 한두명 정도 될 거라고 예상한다. 1년 뒤, 그때도 내가 하루에 한 포스팅을 이어간다면, 100명 정도에게 노출되고, 10명 정도가 보게되지 않을까. 어찌되었건 글을 끄적이는 걸 좋아하는 나니까, 그리고 얼마 전 보글보글 거리는 타건감이 좋은 무접점 키보드도 비싼 돈 주고 구매 했으니까 한번 끄적여 보려 한다. 13학번 컴공생 나는 13학번으로 대구의 한 대학교에 입학을 했다. 내가 고등학생 때 ‘유령’이라는 드라마를 너무 재밌게 본 나머지 “나도 보안 공부를 해서 해커가 될거야!” 하는 허황된 꿈을 꾸며 컴퓨터공학과에 입학을 해야겠다고 생각을 했다. 취직을 하려면 공대가 좋긴 한데, 흔히들 말하는 전,화,기 (전자공학, 화학공학, 기계공학)을 가기에는 4대 역학을 공부하기가 너무 싫었던 이유도 있었다. 모든 신입생들이 그렇듯 나 역시도 ‘Hello World’를 출력할 때 까지만 해도 컴퓨터가 재미있고, 내가 무언가 대단한 것을 한 것 같았다. 동기들과 자취방에서 밤을 새워가며 교수님께서 내 준 문제를 풀며 (사실 밤새 과제만 하진 않았다. 게임을 한 시간이 더 많을 것이다.) 출력창에 원하는 결과물이 띄어졌을 때의 희열은, 물론 그건 지금도 그렇지만, 여튼 그때는 컴퓨터가 내겐 천직일 것만 같았다. 2학년 때 자료구조를 배우기 전 까지는. 2학년 때 자료구조라는 과목을 공부 할 때 그 놈의 ‘링크드 리스트’가 이해가 되지 않아 공부에 흥미를 잃고 게임에 더 빠졌던 것 같다. 몇년도 더 된 일이라 정확하게는 기억이 나지 않지만, 그렇게 점점 학교 공부는 소홀해 져 갔고, 그러다보니 아예 수업은 빠지고 결국 기말때는 출석조차 하지 않았다. ‘C++(C++로 자료구조를 구현하는 수업이었다.)은 C+ 맞아야지~’ 하는 우스갯 소리와 함께 정말 C+을 맞게되고, 다른 과목도 성적이 더하면 더했지 덜하지는 않아 그렇게 2학년 1학기는 학고를 맞게 된다. 1학년 때는 학고 맞는 친구들은 어지간히 공부를 안했나보다, 그냥 교수님 하라는거 하고 보라는거 보면 B는 나오는데 좀만 열심히 하면 A가 나올텐데 D,F를 맞아서 학고 받는 애들은 뭐하는 애들이야 했었는데, 내가 그 학사경고를 받은 놈이 되어있었다. 이맘때 즘 부터 컴퓨터로 전공을 살리지 않고 취직해야겠다는 생각을 하게 되었다. 휴학과 다른 진로 탐색 우리 학교는 특이하게도 학고를 맞으면 집으로 경고장이 날아오게 되어있다. 애석하게도 나는 그 사실을 몰랐고, 불행하게도 그 등기 우편물은 내가 아닌 어머니가 먼저 보시게 되었다. 그래도 나는 고등학생 때 사고 한번 치지 않고 조신히 학교 다니던 나름 모범생(…?) 이었고 학사경고장을 받아올 줄은 꿈에도 생각치 않으셨던 어머니께서는 휴학하고 군대를 다녀와서 다시 공부하자고 말씀 해 주셨고, 큰 화는 내지 않으셨다. 이제 성인이라시며 니 인생을 이제 니가 책임 질 줄 알아야 한다는 말씀만 하셨다. (지금 생각하면 21살이면 아무것도 못하는 어린애지…) 그렇게 군대를 가기 위해 휴학을 하고 이런 저런 경험들을 하다가 영상 제작에 재미를 붙이게 되고 유튜브가 지금처럼 잘 되어 있지 않던 그 당시 페이스북 채널로 영상인 커뮤니티를 통해 많은 사람들을 알게되었다. 지금 꽤나 큰 규모의 유튜브 채널을 운영하고 있는 유튜버들도 몇 있었다. 그 때 친하게 지내 놓을걸… 어찌되었건 영상에 빠져 이런 저런 영상 기획을 하고 촬영도 해보고 했던 경험은 나름 재밌는 경험으로 남아있다. 이때 이야기까지 하게되면 글이 너무 길어질 것 같아 각설하고 넘어가도록 하겠다. 제대 후 학교 선배와의 창업 보통 남자들은 제대 후 복학 한 첫 학기는 성적이 좋다고들 하는데, 이미 전공을 포기한 나는 크게 학교 공부에도 재미를 못 붙이고, 적당히 학고만 맞지 않을 정도로만 해야지 하는 마음가짐이었다. 그렇게 하고 싶은 것들을 찾다보니 노래를 좋아하던 나에게 음악활동을 하는 단체에 들게되었고, 거기서 마음 맞는 학교 선배와 음악 사업을 함께 하게 되었다. 아이템은 간단했다. 좋은 노래지만 낮은 인지도로 세상에 빛 한번 못보고 사라지는 음원과, 그럭저럭한 노래지만, 높은 인지도로 각종 차트 순위권에 들어버리는 노래들 사이에서 아무런 배경 지식 없이 오로지 음악으로만 내 취향의 노래를 찾는 서비스를 만들었었다. 일종의 블라인드 오디션을 모바일 서비스로 하는 아이템을 기획하고 실제 서비스 런칭까지 했었지만, 그때 마침 네이버의 ‘바이브’를 시작으로 다른 유명 스트리밍 사이트에서 이러한 같은 기능들을 넣기 시작했다. 지금 생각해도 나쁘지 않은 아이템이었다고 생각한다. 다만 좀더 공격적으로 유저를 모으고 홍보를 해서 먼저 시장 점유를 했으면 어땠을까 하는 아쉬움은 있는 그런 아이템이었다. 그렇게 첫 사업이 좋지 못하게 끝이나고 피버팅을 해서 다른 사업으로 회사에 매출이 나기 시작했다. 코딩 교육 사업 그렇게 시작한 사업 아이템이 교육 사업이었다. 특히 코딩 교육이 메가 트렌드로 뜨고 너도나도 아이들 코딩 교육을 하려는 붐이 일던 찰나, 우리는 교육이 가능한 공대생 3명이 있었고, 과 동기 후배 선배라는 강사 풀이 있었고, 대구에서 나름 네임밸류가 있는 대학의 학생들이었다. 그렇게 아무것도 없이 밑바닥에서 시작한 사업이 지금은 20명 가량이 되는 직원의 월급을 줄 수 있을 정도의 회사로 성장했다. 나 또한 작년까지만 해도 회사에서 나름 중요한 역할을 하던 창립 맴버였다. 퇴사 아무것도 없이 월세 30의 지하사무실에서 시작해 매출이 없으니 월급도 없이 일 했던 다섯명의 맴버들이 번듯하게 직원들 월급을 줄 수 있는 회사로 성장했다는 스토리는 겉으로만 봐서는 정말 큰 인간 승리로 보일 수 있다. 물론 열심히 일한 만큼 회사가 성장하는 모습이 눈에 띄게 보이니까 일하는 맛도 났고, 내가 이 회사의 처음부터 함께 했다는 자부심에 뿌듯하게 일을 할 수 있었다. 물론 대표님은 나보다 5배는 더 열심히 일 했을 것이다. 회사에서는 대표님이지만 사석에서는 형님이니까 함께 개인적인 자리에서 밥을 먹을 자리가 많았는데, 항상 예전 힘들었던 시절을 회상하며 우리 정말 열심히 했다고 자랑스러워 하며 더더욱 열심히 할 수 있는 힘이 된 적이 많았었다. 그게 3년 정도 지났을 때 체력도 멘탈도 약한 내게 번아웃이 왔고, 정신적으로 많이 힘든 시점이 왔다. 무작정 회사의 눈에 보이는 성장이 좋아서 살다보니 나도 모르게 심적인 여유가 없었던 것일까. 대표님께 내 ‘회사라고 생각하고 열심히 일했는데, 그게 내게 부담으로 다가왔던 것 같다, 이제는 내 회사가 아닌 남의 회사에서 일하고 싶다’며 두달간의 인수인계 후 좀 쉬고 싶다고 말씀드렸고, 대표님도 내 의견을 존중 해 주셨다. 그렇게 3년간의 나를 한층 크게 성장시켜주었던, 인생의 전환점이 되어 주었던 내 첫 회사를 퇴사하게 되었다. 취준 몇 달간 아무 생각 없이 모아 놓은 돈 펑펑 써대며 놀고 먹고 하다보니 이제 슬슬 취준을 해야겠다는 생각이 들었고, 어떤 분야로 취직을 할 것인가에 대한 고민 후 내린 결정은 웃기게도 21살에 그만 둔 컴퓨터였다. 솔직하게 말해서 처음에는 ‘요즘 개발자가 취직이 잘 된다더라’, ‘개발자가 돈을 많이 번다더라’가 시작이었다. 부정하지 않겠다. 다만 내가 공부 하고 싶었던 분야인 광고쪽으로 학부때 신문방송학을 부전공하며 공부할 때 데이터 마케팅을 공부하려 했다는 것이 생각이 나 처음에는 그쪽으로 공부를 시작했다. 지금처럼 웹 개발을 공부하지는 않았다. 데이터공학을 공부하기 위해 파이썬을 다시 공부했고, 데이터 전처리를 공부하던 도중 백엔드에 관심을 갖게 되었고, 웹을 공부해보자는 마음으로 일단 프론트를 공부해보자고 시작한 게 이 블로그다. 이렇게 보니까 되게 의식의 흐름이 내 쪼대로 흘러가고 있긴 한데, 애초에 나란 녀석이 인생은 내 하고싶은거 하고 살자는 마음이라, 내 좌우명대로 현재를 즐기기 위해 노력하며 살고있다. 20살때부터 8년간 장래희망이 4번 바뀌었다. 돌고 돌아 처음으로 돌아왔으니 뭐 3번이라고 하자. 2년 뒤 내가 갑자기 배우가 하고 싶을지, 인생을 어떻게 알겠는가. 어찌되었건 현재의 나는 내년 하반기 판교 입성을 목표로 학부 2학년 때로 돌아가 다시 공부하며 지내고 있다. 끝맺으며 아무 생각 없이 내 인생을 회상하며 글을 끄적여 내려가다보니 30분이 넘도록 글을 쓰고 있다. 이렇게 옛날을 회상하며 글을 끄적이다보니 짧지도 그렇다고 길지도 않은 세월을 살았지만 그 사이에 많은 우여곡절이 있었구나 하며 내 인생을 돌이켜 볼 수 있는 나름 소중한 시간이었다. 처음 시작할 때는 아무도 안 볼 글인데(아마 내 여자친구가 보지 않을까 싶긴 하지만) 대충 적다가 잠이나 자자는 생각이었는데, 내 인생 그래도 헛 살진 않았구나 하며 내 스스로를 토닥여 줄 수 있는 생각보다 굉장히 뜻깊은 시간이었다. 이 긴 글을 여기까지 보는 사람이 몇이나 될지는 모르지만 그대들은 대한민국 7천만 인구 중, 한 명의 20대 청년의 인생 요약본을 보았다. 이 글을 다 읽는데 5분은 걸릴텐데 과연 이 5분이 그대들에게 어떤 시간이었을지 모르겠다. 그저 세상엔 저런 애도 있구나, 했을 수도, 인생 즐기면서 살다가 나락가는거지, 했을 수도, 도전 하는 모습이 멋있다, 했을 수도. 어떤 반응이던 나라는 사람의 인생을 보는데 5분이라는 시간을 투자한 그대들이, 나를 한심하게 보았다면 반면교사로, 나를 대단하게 보았다면 롤모델으로, 어찌되었건 이 5분이 값진 시간이 되었으면 한다. 내가 아무 생각없이 끄적이다보니 생각보다 뜻깊은 시간이 되었던 것 처럼. 오랜만에 사색에 잠겨 끄적였더니 새벽감성도 느끼고 좋은 시간이었던 것 같다. 앞으로 종종 일기처럼 생각 정리하는 시간도 갖곤 해야겠다.",
    "tags": "diary essay",
    "url": "/essay/2021/06/10/essay/"
  },{
    "title": "Linked List",
    "text": "Singly Linked List 단일 연결 리스트 순차적으로 연결된 공간에 데이터를 나열하는 배열과 달리 링크드 리스트는 떨어진 곳에 존재하는 데이터를 연결해서 관리하는 데이터 구조 파이썬은 리스트 타입이 링크드 리스트의 기능을 모두 지원해 줌 Node = data + link 노드(Node) 데이터 저장 단위 (데이터값, 포인터) 로 구성 포인터(pointer) 각 노드 안에서, 다음이나 이전의 노드와의 연결 정보를 가지고 있는 공간 출처 : https://en.wikipedia.org/wiki/Linked_list 일반적인 단일 연결 리스트의 형태 class Node: def __init__(self, data): self.data = data self.next = None class SinglyLinkedList: def __init__(self, data): self.head = Node(data) def add(self, data): if self.head == '': self.head = Node(data) else: node = self.head while node.next: node = node.next node.next = Node(data) def desc(self): node = self.head while node: print (node.data) node = node.next def delete(self, data): if self.head == '': print ('해당 값을 가진 노드 없음') return # 경우의 수1: self.head를 삭제해야할 경우 -&gt; self.head를 바꾼 뒤 삭제 if self.head.data == data: temp = self.head self.head = self.head.next del temp else: node = self.head # 경우의 수2: self.head가 아닌 노드를 삭제해야할 경우 while node.next: if node.next.data == data: temp = node.next node.next = node.next.next del temp pass else: node = node.next def search_node(self, data): node = self.head while node: if node.data == data: return node else: node = node.next 단순 연결 리스트 메소드 구현 장점 미리 데이터 공간을 할당 해야 하는 배열과 달리 데이터 공간을 미리 할당하지 않아도 됨 단점 연결을 위한 별도 데이터 공간이 필요하므로 저장 공간 효율이 높지 않음 데이터를 찾는 시간이 필요하므로 접근 속도가 느림 중간 데이터 삭제 시, 앞뒤 데이터의 연결을 재구성해야 하는 부가적인 작업 필요 Doubly Linked List 이중 연결 리스트 양방향으로 연결되어 있어서 노드 탐색이 양쪽으로 모두 가능 단순연결리스트와는 다르게 상수시간 내 역방향 연산이 가능 Node = data + next_link + prev_link 출처 : https://en.wikipedia.org/wiki/Linked_list 이중 연결 리스트의 형태 class Node: def __init__(self, data, prev=None, next=None): self.prev = prev self.data = data self.next = next class DoublyLinkedList: def __init__(self, data): self.head = Node(data) self.tail = self.head def insert_before(self, data, before_data): if self.head == None: self.head = Node(data) return True else: node = self.tail while node.data != before_data: node = node.prev if node == None: return False new = Node(data) before_new = node.prev before_new.next = new new.next = node return True def insert_after(self, data, after_data): if self.head == None: self.head = Node(data) return True else: node = self.head while node.data != after_data: node = node.next if node == None: return False new = Node(data) after_new = node.next new.next = after_new new.prev = node node.next = new if new.next == None: self.tail = new return True def insert(self, data): if self.head == None: self.head = Node(data) else: node = self.head while node.next: node = node.next new = Node(data) node.next = new new.prev = node self.tail = new def desc(self): node = self.head while node: print (node.data) node = node.next 이중 연결 리스트 메소드 구현 Circular Linked List 원형 연결 리스트 마지막 노드를 참조하는 last가 단순연결리스트의 head 역할을 함 마지막 노드와 첫 노드를 O(1) 시간에 방문할 수 있음 빈 리스트가 아니면 어떤 노드도 None을 가지고 있지 않아서 프로그램에서 None 조건을 검사하지 않아도 됨 비슷한 원리로 Circularly Doubly Linked List도 구현 가능 출처 : https://en.wikipedia.org/wiki/Linked_list 원형 연결 리스트의 형태 참고 위키피디아 잔재미코딩 신찬수 교수님 유튜브",
    "tags": "datastructure computerscience",
    "url": "/computerscience/2021/06/09/cs_ds_01/"
  },{
    "title": "[프로그래머스 / lv.1] 예산",
    "text": "날짜: 2021년 6월 7일 소요 시간: 6분 11초 카테고리: 수학문제 태그: 레벨1, 파이썬 코딩테스트 연습 - 예산 입출력 예시 d budget result [1,3,2,5,4] 9 3 [2,2,3,3] 10 4 내가 적은 코드 def solution(d, budget): d.sort() count = 0 bud = 0 for i in d: bud += i if bud &gt; budget: break count += 1 return count 풀이 과정 신청한 부서 d를 내림차순으로 정렬하여 하나하나씩 더해 주어 bud에 저장 한 후 저장 한 부서만큼 count에 +1씩 해준다. bud가 예산을 나타내는 파라미터인 budget보다 커지게 될 경우 반복을 멈추고 count를 리턴한다. 베스트 코드 def solution(d, budget): d.sort() while budget &lt; sum(d): d.pop() return len(d) 신청한 부서 d가 많고 예산 budget이 적으면 리스트 뒤에서 부터 pop하며 읽어내려가기 때문에 비효율적인 코드가 될 수도 있다. 반성 어렵게 생각할 필요가 없던 문제인데 6분이나 소비하였다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/06/07/ap_pg_post1/"
  },{
    "title": "Stack &amp; Queue &amp; Deque",
    "text": "제한된 접근(삽입, 삭제)만 허용 (Stack, Queue, Dequeue 모두 동일) 출처 : https://gohighbrow.com/stacks-and-queues/ 스택과 큐의 구조를 가장 잘 보여주는 예시 Stack 스택 class Stack: def __init__(self): self.items = []. #데이터 저장을 위한 리스트 준비 def push(self, val): self.items.append(val) def pop(self): try: return self.items.pop() #pop할 item이 없으면 except IndexError: print(\"Stack is empty\") #indexError 발생 def top(self): try: return self.items[-1] except IndexError: print(\"Stack is empty\") def __len__(self): return len(self.items) #len()로 호출하면 Stack의 item 수 반환 파이썬에서 스택은 범용 자료구조인 List를 활용하여 사용할 수 있다. 특징 LIFO : Last In First Out 가장 최근에 push된 요소가 먼저 pop된다 (후입선출) append → push pop → pop 활용 예시 웹 브라우저 뒤로 가기 : 가장 최근에 열린 페이지부터 다시 보여줌 실행 취소 (Ctrl + Z) : 가장 나중에 실행된 작업을 되돌려줌 Queue 큐 class Queue: def __init__(self): self.items = [] #빈 리스트 self.front_index = 0 def enqueue(self, val): self.item.append(val) def dequeue(self): if self.front_index == len(self.items): print(\"Queue is empty\") return None else: x = self.items[front_index] self.front_index += 1 return x List를 활용해서 큐를 사용할 수 있는 클래스를 만들 수도 있다. from queue import Queue que = Queue() que.put(val) que.get() 파이썬에 내장되어 있는 queue 모듈을 활용하여 보다 쉽게 코드를 작성할 수 있다. 특징 FIFO : First In First Out enqueue된 순서대로 dequeue된다 (선입선출) front에서 dequeue되고 Rear에서 enqueue된다. append → enqueue → put pop → dequeue → get queue 모듈의 Queue 클래스에 대한 자세한 내용은 여기 파이썬 공식 레퍼런스 참고 활용 예시 은행 번호표 : 가장 먼저 온 사람의 번호를 먼저 띄워 줌 프린터 인쇄 대기열 : 우선 순위가 같은 작업 중 가장 먼저 들어 온 문서부터 인쇄함 Dequeue (double-end-queue) 덱 from collections import deque makeDeque() #덱 생성 appendleft() #맨 앞(왼쪽)에 자료 추가 pop() #맨 앞(왼쪽)에 자료 삭제 append() #맨 뒤(오른쪽)에 자료 추가 popleft() #맨 뒤(오른쪽)에 자료 삭제deque(maxlen=n) reverse() #deque의 순서 뒤집음 count(x) #deque에 포함된 x의 개수 반환 clear() #deque 값 모두 삭제 덱은 collections 모듈의 deque 클래스를 활용하면 보다 쉽게 코드를 작성할 수 있다. 특징 Stack과 Queue를 합친 형태 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조 list와 deque 비교 시간 복잡도 insert, remove, popleft indexing, slicing list O(n) O(1) deque O(n) O(n) 고정된 길이 내에서 접근, 검색, 슬라이싱을 하는 데에는 list가 유리 데이터를 추가 or 삭제할 땐 deque이 유리 참고 신찬수 교수님 유튜브",
    "tags": "datastructure computerscience",
    "url": "/computerscience/2021/06/05/cs_ds_01/"
  },{
    "title": "[프로그래머스 / lv.2] 124 나라의 숫자",
    "text": "날짜: 2021년 6월 4일 소요 시간: 1시간 10분 48초 카테고리: 수학문제 태그: 레벨2, 파이썬 코딩테스트 연습 - 124 나라의 숫자 입출력 예시 10진법 124 나라 10진법 124 나라 1 1 6 14 2 2 7 21 3 4 8 22 4 11 9 24 5 12 10 41 내가 적은 코드 def solution(n): arr = [] while n != 0: n -= 1 i = n % 3 arr.append('124'[i]) n //= 3 return \"\".join(arr[::-1]) 풀이 과정 3진법 만드는 로직과 비슷하게 작동하나 1의 자리 수가 0이 없다는 점을 감안해서 n-1을 하여 풀어줘야 한다. 0 대신 1 / 1 대신 2 / 2 대신 4 이렇게 들어가게끔 문자열 인덱싱을 해 주었고, 리스트에 append해서 마지막에 거꾸로 뒤집은 리스트를 join함수로 문자열화 시켰다. 사실 그냥 처음부터 문자열로 풀었으면 훨씬 간단했을 코드이다. 베스트 코드 # 베스트 코드 1 def change124(n): num = ['1','2','4'] answer = \"\" while n &gt; 0: n -= 1 answer = num[n % 3] + answer n //= 3 return answer 나와 같은 방식으로 풀었으나 나는 리스트로 풀었고 이 분은 문자열으로 풀었다. 문자열이 좀더 효율적인 것 같긴 하다. 대신 이 분은 1,2,4를 리스트에 넣어서 인덱싱 해줘서 나와 반대로 바보같은 짓을 했다. # 베스트 코드 2 def change124(n): if n&lt;=3: return '124'[n-1] else: q, r = divmod(n-1, 3) return change124(q) + '124'[r] 재귀함수로 풀어 훨씬 깔끔해진 코드. 재귀함수도 익숙해 질 필요가 있을 것 같다. 반성 로직을 생각해 내는데 너무 많은 시간을 허비하였다. 말이 level.2 이지 사실 로직이 조금 복잡한 1정도 수준의 문제였다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/06/04/ap_pg_post2/"
  },{
    "title": "[프로그래머스 / lv.1] 3진법 뒤집기",
    "text": "날짜: 2021년 6월 4일 소요 시간: 16분 16초 카테고리: 인덱싱 태그: 레벨1, 파이썬 코딩테스트 연습 - 3진법 뒤집기 입출력 예시 n return 45 7 125 229 내가 적은 코드 def solution(n): answer = 0 num = [] while n != 0: m = n % 3 n = n // 3 num.append(m) num = num[::-1] for i in range(0,len(num)): answer += num[i] * (3**i) return answer 풀이 과정 정수형 n을 0이 될 때까지 나눈 나머지를 num에 저장한다. (기본적인 진수 변환 법) 그리고 num의 원소를 거꾸로 뒤집은 각 원소를 3의 i승씩 곱해준다. 베스트 코드 def solution(n): tmp = '' while n: tmp += str(n % 3) n = n // 3 answer = int(tmp, 3) return answer 반성 문자열 인덱싱을 통하지 않고 바로 정수형으로 풀 수 있는 문제였다. 좀 더 머리를 굴렸으면 보다 빠른 코드를 짤 수 있었다. int()함수를 통해 진법을 바꿀 수 있다는 사실을 알았다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/06/04/ap_pg_post1/"
  },{
    "title": "[프로그래머스 / lv.1] 문자열 내 마음대로 정렬하기",
    "text": "날짜: 2021년 6월 3일 소요 시간: 2시간 초과 카테고리: 인덱싱 태그: 레벨1, 파이썬,time_out 코딩테스트 연습 - 문자열 내 마음대로 정렬하기 입출력 예시 strings n return [“sun”, “bed”, “car”] 1 [“car”, “bed”, “sun”] [“abce”, “abcd”, “cdx”] 2 [“abcd”, “abce”, “cdx”] 내가 적은 코드 # 문제를 풀지 못하였다. 풀이 과정 문제를 풀지 못하였다. 베스트 코드 def solution(strings, n): return sorted(strings, key=lambda x: x[n]) 반성 sort 함수에 key 값을 넣어 정렬하는 것과, lambda의 이해도가 낮아서 이런 풀이를 생각조차 하지 못했다. 3중 반복문으로 어떻게든 풀어보려했었던 내가 자괴감이든다….",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/06/03/ap_pg_post2/"
  },{
    "title": "[프로그래머스 / lv.1] 이상한 문자 만들기",
    "text": "날짜: 2021년 6월 3일 소요 시간: 23분 09초 카테고리: 인덱싱 태그: 레벨1, 파이썬 코딩테스트 연습 - 이상한 문자 만들기 입출력 예시 s return “try hello world” “TrY HeLlO WoRlD” 내가 적은 코드 def solution(str): answer = [] i = 0 j = 0 for i in range(0,len(str)): if j % 2 == 0: answer.append(str[i].upper()) j += 1 else: answer.append(str[i].lower()) j += 1 if str[i] == ' ': j = 0 return ''.join(answer) 풀이 과정 str의 문자열을 하나씩 슬라이싱해서 띄어쓰기를 기준으로 짝수번 문자는 대문자, 홀수번 문자는 소문자로 배열 answer에 저장한다. 띄어쓰기를 기준으로 j를 0으로 초기화하여 기준을 잡고 대소문자를 구분 할 짝,홀수번째 문자를 정한다. 그리고 배열 answer의 원소들을 join() 함수를 통해 하나의 문자열로 출력한다. 베스트 코드 def toWeirdCase(s): # 함수를 완성하세요 return ' '.join([''.join([c.upper() if i % 2 == 0 else c.lower() for i, c in enumerate(w)]) for w in s.split()]) 반성 알고리즘 책에서 enumerate()함수에 대해 보기는 했으나 실제로 사용되는 경우는 처음봤다. 다양한 함수, 모듈들이 더 눈에 익어 직접 활용할 수 있게 만들어야한다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/06/03/ap_pg_post1/"
  },{
    "title": "[프로그래머스 / lv.1] 수박수박수박수박수박수?",
    "text": "날짜: 2021년 6월 1일 소요 시간: 05분 03초 카테고리: 인덱싱 태그: 레벨1, 파이썬 코딩테스트 연습 - 수박수박수박수박수박수? 입출력 예시 n return 3 “수박수” 4 “수박수박” 내가 적은 코드 def solution(n): watermelon = [\"수\"] for i in range(0,n-1): if watermelon[i] == \"수\": watermelon.append(\"박\") else: watermelon.append(\"수\") return \"\".join(watermelon) 풀이 과정 문자열의 이전 원소가 “수”일 경우 다음 원소로 “박”을 추가하고 이전 원소가 “박”일 경우 다음 원소로 “수”를 추가하는 동작을 n번 반복한다. 베스트 코드 def water_melon(n): return \"수박\"*(n//2) + \"수\"*(n%2) 반성 O(1)으로 짤 수 있는 코드를 O(n)로 짰다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/06/01/ap_pg_post1/"
  },{
    "title": "[프로그래머스 / lv.1] 시저 암호",
    "text": "날짜: 2021년 5월 31일 소요 시간: 33분 39초 카테고리: 수학 문제 태그: 레벨1, 파이썬 코딩테스트 연습 - 시저 암호 입출력 예시 s n result “AB” 1 “BC” “z” 1 “a” “a B z” 4 “e F d” 내가 적은 코드 def solution(s, n): alphabet = 'abcdefghijklmnopqrstuvwxyz' answer = list() for i in range(0,len(s)): if s[i].isupper(): for j in range(0, len(alphabet)): if s[i] == alphabet[j].upper(): answer.append(alhpabet[(j+n)%26].upper()) break if s[i].islower(): for k in range(0, len(alphabet)): if s[i] == alphabet[k]: answer.append(alphabet[(k+n)%26]) break if s[i] == \" \": answer.append(\" \") return \"\".join(answer) 풀이 과정 문자열 s의 원소가 대문자인 경우 (첫번째 조건) 알파벳 소문자로 이루어진 문자열 alphabet을 대문자화 하여 answer에 저장 문자열 s의 원소가 소문자인 경우 (두번째 조건) 알파벳 소문자로 이루어진 문자열 alphabet을 answer에 저장 문자열 s의 원소가 공백인 경우 (세번째 조건) 공백을 answer에 저장 n번째 원소가 26번째(z번쨰보다 큰 수)일 경우 26으로 나눈 나머지 번째의 원소(다시 a로 돌아감)를 출력 리스트 형인 answer에 저장 되어있는 원소를 문자형으로 출력하기 위해 join()함수를 사용 베스트 코드 def caesar(s, n): s = list(s) for i in range(len(s)): if s[i].isupper(): s[i]=chr((ord(s[i])-ord('A')+ n)%26+ord('A')) elif s[i].islower(): s[i]=chr((ord(s[i])-ord('a')+ n)%26+ord('a')) return \"\".join(s) 반성 시프트로 푸는 방법을 생각은 했으나 ord()와 chr()함수를 몰라서 코드화 할 수 없었다. 더 많은 파이썬 모듈이나 함수를 알면 더 효율적으로 코드를 짤 수 있다. 파이썬에 대한 공부가 더 필요하다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/31/ap_pg_post2/"
  },{
    "title": "[프로그래머스 / lv.1] 문자열 내 p와 y의 개수",
    "text": "날짜: 2021년 5월 31일 소요 시간: 05분 02초 카테고리: 수학 문제 태그: 레벨1, 파이썬 코딩테스트 연습 - 문자열 내 p와 y의 개수 입출력 예시 s answer “pPoooyY” true “Pyy” false 내가 적은 코드 def solution(s): p_word = 0 y_word = 0 answer = False for i in range(0,len(s)): if s[i] == \"p\" or s[i] == \"P\": p_word += 1 elif s[i] == \"y\" or s[i] == \"Y\": y_word += 1 if p_word == y_word: answer = True return answer 풀이 과정 문자열 s의 길이만큼 반복하여 p나 P가 나오면 p_word에 1씩 더해주고 y나 Y가 나오면 y_word에 1씩 더해주어 p_word와 y_word를 비교하여 boolen 값을 출력한다. 베스트 코드 def numPY(s): return s.lower().count('p') == s.lower().count('y') 반성 더 많은 파이썬 모듈이나 함수를 알면 더 효율적으로 코드를 짤 수 있다. 파이썬에 대한 공부가 더 필요하다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/31/ap_pg_post1-%EB%B3%B5%EC%82%AC%EB%B3%B8/"
  },{
    "title": "[백준 / 1158] 요세푸스 문제",
    "text": "날짜: 2021년 5월 31일 소요 시간: 1시간 42분 12초 카테고리: 자료구조, 큐 태그: silver.5, 1158 , 파이썬 백준 1158 - 요세푸스 문제 입출력 예시 예제 입력 예제 출력 7 3 &lt;3, 6, 2, 7, 5, 1, 4&gt; 내가 적은 코드 N,K = map(int, input().split()) T = 0 que = [] arr = [i for i in range(1,N+1)] while len(arr) != 0: T = (T + K-1) % len(arr) que.append(arr[T]) arr.pop(T) N -= 1 print('&lt;' + ', '.join(map(str,que)) + '&gt;') # 나름 큐로 풀어보겠다고 풀었던 코드 N,K = map(int, input().split()) que = [] arr = [i for i in range(1,N+1)] while len(arr) != 0: i = 1 while i &lt; K: arr.append(arr[0]) arr.pop(0) i += 1 que.append(arr[0]) arr.pop(0) print('&lt;' + ', '.join(map(str,que)) + '&gt;') 풀이 과정 사실 반복문을 통해 한바퀴 돌 때 마다 제거하는 방식보다 큐를 활용하여 한번 풀어보려 했으나 파이썬에서 (내 나름대로 한번) 큐를 구현해서 실행시켰더니 시간 초과가 났다. 반복을 통해 + K-1) % len(arr) 번째씩 더해가며 원소를 pop하고 그 원소를 que에 저장했다. 베스트 코드 n, m = map(int, input().split()) l = list(range(1, n + 1)) r = [] index = 0 while l: index = (index + m - 1) % len(l) r.append(str(l.pop(index))) print('&lt;', ', '.join(r), '&gt;', sep='') 반성 알고리즘 적으로 베스트 코드와 다르지 않았다는 점에서 실력이 늘어감을 느낀다. 시간 복잡도를 줄인 큐를 통해 풀 수 있는 방법을 찾지 못하였다.",
    "tags": "baekjoon algorithmpractice",
    "url": "/algorithmpractice/2021/05/31/ap_bj_post1-%EB%B3%B5%EC%82%AC%EB%B3%B8/"
  },{
    "title": "[프로그래머스 / lv.1] 크레인 인형뽑기 게임",
    "text": "날짜: 2021년 5월 30일 소요 시간: 58분 24초 카테고리: 수학 문제 태그: 레벨1, 파이썬 코딩테스트 연습 - 크레인 인형뽑기 게임 입출력 예시 board moves result [[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]] [1,5,3,5,1,2,1,4] 4 내가 적은 코드 def solution(board, moves): arr = [] answer = 0 for i in moves: for j in range(len(board)): if board[j][i-1] != 0: arr.append(board[j][i-1]) board[j][i-1] = 0 if len(arr) &gt; 1 and arr[-1] == arr[-2]: arr.pop(-1) arr.pop(-1) answer += 2 break return answer 풀이 과정 i는 크레인이 움직인 행을 의미한다.(배열의 첫번째가 0으로 시작하므로 -1을 해준다.) j는 board의 열을 의미한다. 그래서 0이 아닌 그러니까 인형이 존재하는 칸을 만났을 때 그 원소를 0으로 치환하고 그 값은 arr에 담는다. 만약 arr의 맨 뒤의 두 원소가 같을 때 두 개의 원소를 pop하고 결과 값에 2를 더한다. 그럼 마지막에는 사라진 인형의 개수가 answer에 저장된다. 베스트 코드 def solution(board, moves): stacklist = [] answer = 0 for i in moves: for j in range(len(board)): if board[j][i-1] != 0: stacklist.append(board[j][i-1]) board[j][i-1] = 0 if len(stacklist) &gt; 1: if stacklist[-1] == stacklist[-2]: stacklist.pop(-1) stacklist.pop(-1) answer += 2 break return answer 반성 이제 레벨 1정도의 브루트 포스 알고리즘의 로직은 어느정도 구현할 수 있는 것 같다. 구현 단계에서 파이썬의 기본적인 문법에 대한 이해도가 낮아서 리스트 슬라이싱이라던지 자료형이라던지에서의 실수가 잦다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/30/ap_pg_post1-%EB%B3%B5%EC%82%AC%EB%B3%B8/"
  },{
    "title": "Array &amp; List",
    "text": "Array 배열 특징 연속된 메모리 공간에 할당 무작위 접근(Random Access) 가능 정적 배열 지역성을 가짐 탐색에 효율적 C의 Array Java의 Array 장점 인덱스를 통한 검색에 빠른 성능을 보여줌 연속적 메모리 공간에 할당되어 순차 접근도 빠름 단점 한 데이터를 삭제 하더라도 처음 할당 된 사이즈만큼 데이터가 없더라도 메모리를 차지하고 있어서 메모리 재사용이 불가능 정적이므로 배열의 크기를 정해주어야 함 삽입 삭제 시 요소들을 이동해야 해서 비효율적 선언시 지정한 배열의 크기를 변동 불가 List 리스트 특징 불연속 적으로 메모리 공간을 할당 포인터를 통한 접근 동적 배열 추가, 삭제에 효율적 Python의 List Java의 ArrayList 장점 삽입 삭제 시 전후 노드의 참조 관계만 수정하면 되어 효율적 동적이므로 크기가 정해져 있지 않음 메모리의 재사용 가능 포인터를 통한 접근 불연속적이므로 메모리 관리의 편리 단점 검색이 비효율적 포인터를 통해 다음 데이터의 위치를 가르키고 있어 추가적인 메모리 공간 발생 Array (배열) 저장할 데이터의 크기가 정해져 있고, 추가적인 삽입 삭제가 적고, 특정 위치의 데이터를 조회하는 작업이 많다면 유리 List (리스트) 저장할 데이터의 개수가 미정이고, 삽입 삭제가 많이 일어나며, 특정 위치의 데이터를 조회하는 경우가 별로 없다면 유리 참고 신찬수 교수님 유튜브",
    "tags": "datastructure computerscience",
    "url": "/computerscience/2021/05/27/cs_ds_01/"
  },{
    "title": "[프로그래머스 / lv.2] 주식가격",
    "text": "날짜: 2021년 5월 27일 소요 시간: 22분 04초 카테고리: 스택/큐 태그: 레벨2, 파이썬 코딩테스트 연습 - 주식가격 입출력 예시 prices return [1,2,3,2,3] [4,3,1,1,0] 내가 적은 코드 def solution(prices): answer = [] for i in range(0,len(prices)): j = 0 while prices[i] &lt;= prices[i + j] and i + j != len(prices) - 1: j += 1 answer.append(j) return answer 풀이 과정 prices[i+j](비교 주식 가격)이 prices[i](현재 주식 가격)보다 작아질 때까지 j가 1씩 증가하게 하여 비교 주식 가격이 현재 주식 가격보다 작아지면 j를 answer 리스트 원소로 추가한다. 베스트 코드 def solution(p): ans = [0] * len(p) stack = [0] for i in range(1, len(p)): if p[i] &lt; p[stack[-1]]: for j in stack[::-1]: if p[i] &lt; p[j]: ans[j] = i-j stack.remove(j) else: break stack.append(i) for i in range(0, len(stack)-1): ans[stack[i]] = len(p) - stack[i] - 1 return ans 반성 이제 브루트포스 코드보다 자료구조를 생각하면서 시간복잡도를 줄이는 코딩을 신경써야겠다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/27/ap_pg_post1/"
  },{
    "title": "[백준 / 1213] 팰린드롬 만들기",
    "text": "날짜: 2021년 5월 26일 소요 시간: 2시간 초과 카테고리: 구현, 문자열 태그: silver.4, 1213 , 파이썬, time out 백준 1213 - 팰린드롬 만들기 입출력 예시 예제 입력 예제 출력 AABB ABBA 내가 적은 코드 # 문제를 풀지 못하였다. 풀이 과정 문제를 풀지 못하였다. 베스트 코드 err = lambda:print(\"I'm Sorry Hansoo\") s=list(input()) s.sort() d={} for i in s: if d.get(i) != None: d[i]+=1 else: d[i]=1 last='' for k,v in d.items(): if (v%2==1 and last!=''): err() exit(0) if v%2==1: last=k o=\"\" for k,v in d.items(): o+=k*(v//2) print(o+last+o[::-1]) 반성 lambda 함수와 dictionary의 get함수에 대한 이해도가 낮아 정답 코드를 보고도 코드를 이해하는 데 시간이 걸렸다. 파이썬에 대한 이해도도 높일 필요가 있고, 알고리즘 이론적인 부분도 공부할 필요를 느꼈다. 알고리즘 문제를 푸는 비중보다 이론적인 부분을 공부하는 비중을 더 높여야겠다.",
    "tags": "baekjoon algorithmpractice",
    "url": "/algorithmpractice/2021/05/26/ap_bj_post1/"
  },{
    "title": "[백준 / 1254] 팰린드롬 만들기",
    "text": "날짜: 2021년 5월 25일 소요 시간: 2시간 초과 카테고리: 브루트포스 알고리즘 태그: silver.1, 1254, 파이썬, time out 백준 1254 - 팰린드롬 만들기 입출력 예시 예제 입력 예제 출력 abab 5 내가 적은 코드 # 문제를 풀지 못하였다. 풀이 과정 문제를 풀지 못하였다. 베스트 코드 def check(s): isPelin = True for i in range(len(s)//2): if s[i] != s[len(s)-1-i]: isPelin = False break return isPelin s = list(input()) front = list(s) back = [] count = 0 for i in range(len(s)): if check(s): print(len(s)+count) break else: count += 1 back.insert(0, front[i]) if check(front+back): print(len(s)+count) break 반성 처음으로 제한 시간 2시간 안에 다 풀지 못한 문제 정답을 봤을 때 이해가 된다는 건 내가 문제를 많이 풀어보지 않아서 로직은 알지만 코드로 구현을 못하는 거라고 생각한다. 더 많이 풀어서 경험을 늘리는 게 중요하다.",
    "tags": "baekjoon algorithmpractice",
    "url": "/algorithmpractice/2021/05/25/ap_bj_post1/"
  },{
    "title": "[백준 / 1990] 소수인팰린드롬",
    "text": "날짜: 2021년 5월 24일 소요 시간: 1시간 53분 22초 카테고리: 수학 문제 태그: gold.5, 1990, 파이썬 백준 1990 - 소수인팰린드롬 입출력 예시 예제 입력 예제 출력 5 550 5   7   11   101   131   151   181   191   313   353   373   383   -1 내가 적은 코드 def palin(x): a = str(x) b = a[::-1] if a == b: return True else: return False def prime(x): for num in range(2,int((x**0.5))+1): if x % num == 0: return False break return True a, b = map(int, input().split(\" \")) if b &gt; 10000000: b = 10000000. #임의로 지정해준 값 for num in range(a, b+1): if palin(num): if prime(num): print (num) print (-1) 풀이 과정 팰린드롬을 찾는 함수를 정의하고, 소수를 찾는 함수를 정의하여 a와b 범위 안에 두가지를 충족하는 수를 찾는 방식 소수를 찾는 함수에서 소요 시간이 길어져서 줄이기 위해 별 방법을 다 쓰다가 결국 10000000 이상의 소수인팰린드롬이 없다는 전제를 넣어서야 비로소 제한 시간 내에 풀 수 있었다. 애초에 이걸 파이썬으로 풀 수는 있는 건가… 베스트 코드 import sys def isp(n): if n == 1: return False for i in range(2, int(n ** 0.5) + 2): if n % i == 0: return False return True n, m = input().split() nn = int(n) mm = int(m) ln = len(n) lm = len(m) for i in range(ln, lm + 1): if i % 2: lll = i // 2 + 1 for now in range(10 ** (lll - 1), 10 ** lll): nttn = str(now) nini = nttn[:-1] + nttn[::-1] nownum = int(nini) if nownum &gt;= nn and nownum &lt;= mm and isp(nownum): sys.stdout.write(nini) sys.stdout.write(\"\\n\") else: lll = i // 2 for now in range(10 ** (lll - 1), 10 ** lll): nttn = str(now) nini = nttn + nttn[::-1] nownum = int(nini) if nownum &gt;= nn and nownum &lt;= mm and isp(nownum): sys.stdout.write(nini) sys.stdout.write(\"\\n\") sys.stdout.write(\"-1\") 풀 수 있었다… 유일하게 임의로 수를 지정해 주지 않고 푼 코드 파이썬으로 시간 내에 코드를 돌아가게 하려면 파이썬 특성 상 이해도를 높여서 코드를 효율적으로 짜는 능력을 상당히 많이 끌어올려야 될 것 같다. 이걸 봐도 어떤 부분에서 내 코드보다 시간을 아낄 수 있었는지를 찾을 수 없다… 더 공부를 해야겠다고 느꼈다. 반성 알고리즘이 어렵진 않았다. 다만 실행 시간을 줄이기 위해 2시간을 고민했다.",
    "tags": "baekjoon algorithmpractice",
    "url": "/algorithmpractice/2021/05/24/ap_bj_post2/"
  },{
    "title": "[백준 / 1316] 그룹 단어 체커",
    "text": "날짜: 2021년 5월 24일 소요 시간: 48분 02초 카테고리: 수학 문제 태그: silver.5, 1316, 파이썬 백준 1316 - 그룹 단어 체커 입출력 예시 예제 입력 예제 출력 3 3 happy   new   year   4 1 aba   abab   abcabc   a   내가 적은 코드 N = int(input()) count = 0 i = 0 while i &lt; N: voca = input() voca_check = [voca[0]] for j in range(1,len(voca)): if voca[j-1] != voca[j]: voca_check.append(voca[j]) if len(set(voca_check)) == len(voca_check): count += 1 i += 1 print(count) 풀이 과정 입력된 문자열을 첫번째 알파벳부터 그 다음 알파벳을 비교하여 다른 알파벳이 나왔을 경우 voca_check 리스트에 알파벳을 저장하여 voca_check 리스트에서 중복을 제외한 길이와 그냥 voca_check의 길이가 같을 경우 이 수는 그룹 단어이다. 베스트 코드 result = 0 for i in range(int(input())): word = input() if list(word) == sorted(word, key=word.find): result += 1 print(result) 반성 sorted 함수에 대한 이해도가 낮아 훨씬 간단해 질 수 있는 코드를 길게 풀어썼다.",
    "tags": "baekjoon algorithmpractice",
    "url": "/algorithmpractice/2021/05/24/ap_bj_post1/"
  },{
    "title": "[백준 / 1259] 팰린드롬수",
    "text": "날짜: 2021년 5월 23일 소요 시간: 13분 28초 카테고리: 수학 문제 태그: bronze.1, 1259, 파이썬 백준 1259 - 팰린드롬수 입출력 예시 예제 입력 예제 출력 121 yes 1231 no 12421 yes 0   내가 적은 코드 while True: N = input() if N == '0': break for i in range(len(N)//2): if N[i] != N[len(N)-1-i]: print('no') else: print('yes') 풀이 과정 N이 0이 나올 때 까지 이 동작을 계속 반복한다. (여기서 0은 문자열로 선언 해 주어야 한다.) 입력된 N의 길이의 절반만큼 반복하여 앞에서 i번째 숫자와 뒤에서 i번째 숫자가 다르면 ‘no’를 같으면 ‘yes’를 출력한다. 베스트 코드 n=input() while n!='0': if n==n[::-1]: print('yes') else: print('no') n=input() 반성 input으로 입력한 값의 자료형이 문자열이라는 생각을 하지 못해서 코드 수정하는 데 시간이 너무 많이 걸렸다. 이번 문제는 더 쉽게 풀 수 있었는데 내가 생각이 짧아서 문자열을 뒤집는다는 생각을 하지 못하였다.",
    "tags": "baekjoon algorithmpractice",
    "url": "/algorithmpractice/2021/05/23/ap_bj_post1/"
  },{
    "title": "[백준 / 1475] 방 번호",
    "text": "날짜: 2021년 5월 22일 소요 시간: 56분 39초 카테고리: 수학 문제 태그: silver.5, 1475, 파이썬 백준 1475 - 방 번호 입출력 예시 예제 입력 예제 출력 9999 2 내가 적은 코드 N = list(str(input())) Y = [] for i in range(0,9): Y.append(N.count(str(i))) Y[6] = (Y[6] + N.count(str(9)) + 1)//2 print(max(Y)) 풀이 과정 먼저 정수형으로 입력된 값 N을 문자열로 변환시킨 뒤 문자열인 N의 숫자로 된 원소 0 부터 8까지의 개수를 카운트 해서 리스트 Y에 삽입한다. 그랬을 때 Y[i] = '문자열 N에서 숫자 i의 개수'가 된다. 6과 9는 같은 수로 취급하기 위해 9의 개수를 따로 리스트 Y의 6번째 원소(숫자 6의 개수)에 더해준다. 그랬을 때 리스트 Y의 원소의 최대값을 출력하면 된다. 베스트 코드 c=input().count print(max(int(max(map(c,'01234578'))),(c('6')+c('9')+1)//2)) 반성 자료형이 계속 변하게 코드를 짜다보니 자료형이 헷갈려 오류를 많이 내서 시간을 많이 잡아먹었다. 반복문 하나 없이 같은 정답을 출력하는 베스트 코드처럼 시간복잡도를 줄일 수 있도록 노력하면서 코딩해야한다.",
    "tags": "baekjoon algorithmpractice",
    "url": "/algorithmpractice/2021/05/22/ap_bj_post1/"
  },{
    "title": "[프로그래머스 / lv.1] 약수의 합",
    "text": "날짜: 2021년 5월 21일 소요 시간: 3분 37초 카테고리: 수학 문제 태그: 레벨1, 파이썬 코딩테스트 연습 - 약수의 합 입출력 예시 n return 12 28 5 6 내가 적은 코드 def solution(n): sum = 0 for i in range(1,n+1): if n%i == 0: sum += i return sum 풀이 과정 반복문을 통해서 1부터 n까지의 수 중 n을 나누었을 때 나머지가 0이 되는 수들을 sum에 더하여 sum을 출력한다. 베스트 코드 def sumDivisor(num): return sum([i for i in range(1,num+1) if num%i==0]) 반성 이제는 문제 풀이 뿐 아니라 코드를 짧게 만드는 데에도 시간을 투자해야겠다는 생각이 들었다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/21/ap_pg_post3/"
  },{
    "title": "[프로그래머스 / lv.1] x만큼 간격이 있는 n개의 숫자",
    "text": "날짜: 2021년 5월 21일 소요 시간: 3분 6초 카테고리: 인덱싱 태그: 레벨1, 파이썬 코딩테스트 연습 - x만큼 간격이 있는 n개의 숫자 입출력 예시 n x result 2 5 [2,4,6,8,10] 4 3 [4,8,12] -4 2 [-4,-8] 내가 적은 코드 def solution(x, n): answer = [x] for i in range(1,n): answer.append((answer[i-1]+x)) i += 1 return answer 풀이 과정 반복문을 통해서 리스트 원소를 x만큼 간격을 주어 n만큼 반복해서 리스트에 append 해주었다. 베스트 코드 def number_generator(x, n): # 함수를 완성하세요 return [i * x + x for i in range(n)] 반성 창의적으로 코드를 효율적으로 짧게 하기에는 아직 파이썬에 대한 이해도가 낮다는 느낌이 들었다. 파이썬에 대한 공부가 더 필요하다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/21/ap_pg_post2/"
  },{
    "title": "[프로그래머스 / lv.1] 직사각형 별찍기",
    "text": "날짜: 2021년 5월 21일 소요 시간: 1분 5초 카테고리: 인덱싱 태그: 레벨1, 파이썬 코딩테스트 연습 - 직사각형 별찍기 입출력 예시 입력 5 3 출력 ***** ***** ***** 내가 적은 코드 a, b = map(int, input().strip().split(' ')) print((\"*\" * a +\"\\n\") * b) 풀이 과정 for을 써서 풀까 했는데 굳이 어렵게 갈 필요 없는 문제 같아 보여 쉽게 접근했다. 베스트 코드 # 베스트코드라기보단 그냥 다중 for문 정석같은 풀이 a, b = map(int, input().strip().split(' ')) answer='' for i in range(b): for j in range(a): answer+=\"*\" answer+='\\n' print(answer) 반성 모든 컴퓨터공학 학부 전공생들이 1학년 때 푸는 정석같은 문제라 어렵지 않게 풀었다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/21/ap_pg_post1/"
  },{
    "title": "[백준 / 1193] 분수찾기",
    "text": "날짜: 2021년 5월 21일 소요 시간: 26분 18초 카테고리: 수학 문제 태그: Bronze.2, 1193, 파이썬 백준 1193 - 분수찾기 입출력 예시 예제 입력 예제 출력 14 2/4 내가 적은 코드 X = int(input()) k = X count = 1 i = 1 while (k &gt; count): k -= count count += 1 if count%2 == 1: a = count + 1 - k b = k else: a = k b = count + 1 - k print (a,b, sep='/') 풀이 과정 그림의 빨간색 화살표와 같은 순서로 순차적으로 진행되었을 때 X번째 분수를 구하기 위해서 단락을 나누어 count로 저장하였다. (처음 X를 저장한 k는 단락이 넘어갈 때 마다 count만큼 차감된다.) (ex. 14 -&gt; 13 -&gt; 11 -&gt; 8 -&gt; 4) 파란색 박스를 기준으로 잡았을 때 1/1 -&gt; 1/2, 2/1 -&gt; 3/1, 2/2, 1/3 -&gt; … 순서로 출력 된다. 이런식으로 진행되었을 때 몇번째 count의 몇번째 수를 찾아낼 수 있다. (ex. 14번째 수 -&gt; 5번째 단락의 4번째 수) 그림의 화살표와 파란색 박스를 살펴보면 count가 짝수이면 분모(a)가 n부터 1까지 줄어들고, 분자(b)는 1부터 n까지 증가한다. count가 홀수이면 분자(b)는 1부터 n까지 증가하고, 분모(a)가 n부터 1까지 줄어든다. 규칙만 찾아 낸다면 그렇게 어렵지 않은 문제 였다. 베스트 코드 n = int(input()) c = 2 m = 1 while True: if m &lt; n: m += c c += 1 else : if (c % 2) == 0: print(str(1+(m-n))+\"/\"+str((c-1) - (m-n))) break else: print(str((c-1) - (m-n))+\"/\"+str(1+(m-n))) break 반성 그냥 print했다가 분자,/,분모 사이에 공백이 생긴다는 점을 인지하지 못해서 시간을 많이 버렸다.",
    "tags": "baekjoon algorithmpractice",
    "url": "/algorithmpractice/2021/05/21/ap_bj_post2/"
  },{
    "title": "[백준 / 2501] 약수 구하기",
    "text": "날짜: 2021년 5월 21일 소요 시간: 3분 32초 카테고리: 수학 문제 태그: Bronze.2, 2501, 파이썬 백준 2501 - 약수 구하기 입출력 예시 예제 입력 예제 출력 6 3 3 내가 적은 코드 N, K = map(int, input().split(' ')) arr = [] for i in range(1,N+1): if N%i == 0: arr.append(i) if len(arr) &gt;= K: print(arr[K-1]) else: print(0) 풀이 과정 반복문을 활용해서 1부터 N까지의 수들로 N을 나누었을 때 나머지가 0이되는 수들을 arr의 원소로 추가했다. 그리고 K가 arr의 길이보다 길 때는 0을, K가 arr의 길이보다 작을 때 K번째 원소를 출력하게 했다. 베스트 코드 a, b = map(int, input().split()) c = [i for i in range(1, a+1) if a%i==0] print(0 if len(c)&lt;b else c[b-1]) 반성 더 어렵고 복잡한 난이도의 코드로 넘어가기 전 코드를 짧게 줄이는 연습을 해야되겠다고 생각했다.",
    "tags": "baekjoon algorithmpractice",
    "url": "/algorithmpractice/2021/05/21/ap_bj_post1/"
  },{
    "title": "[프로그래머스 / lv.1] 하샤드 수",
    "text": "날짜: 2021년 5월 20일 소요 시간: 13분 20초 카테고리: 인덱싱 태그: 레벨1, 파이썬 코딩테스트 연습 - 하샤드 수 입출력 예시 arr result 10 true 12 true 11 false 13 false 내가 적은 코드 def solution(x): a = str(x) sum = 0 for i in range(0,len(a)): sum += int(a[i]) if x % sum == 0: answer = True else: answer = False return answer 풀이 과정 int형인 x를 string형으로 변환하여 a에 저장한 후 인덱스 슬라이싱으로 각 자리 수의 합을 sum에 저장하고 x를 sum으로 나누는 방식으로 문제를 풀었다. 베스트 코드 def Harshad(n): return n % sum([int(c) for c in str(n)]) == 0 반성 자료형 변환에 익숙치 않아 시간이 오래 걸렸다. 불린 값을 반환할 땐 굳이 변수에 불린을 넣을 필요가 없는데 쓸떼없이 코드만 늘렸다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/20/ap_pg_post4/"
  },{
    "title": "[프로그래머스 / lv.1] 콜라츠 추측",
    "text": "날짜: 2021년 5월 20일 소요 시간: 4분 8초 카테고리: 수학 문제 태그: 레벨1, 파이썬 코딩테스트 연습 - 콜라츠 추측 입출력 예시 n result 6 8 16 4 626331 -1 내가 적은 코드 def solution(num): count = 0 while num &gt; 1: if num%2 == 0: num = num/2 count += 1 else: num = (num*3) + 1 count += 1 if count &gt;= 500: count = -1 return count 풀이 과정 문제 설명을 그대로 코드로 옮겼다. 한국말을 그대로 파이썬으로 옮긴거라 크게 풀이 과정이라고 할 게 없다. 베스트 코드 def collatz(num): for i in range(500): num = num / 2 if num % 2 == 0 else num*3 + 1 if num == 1: return i + 1 return -1 반성 처음부터 while을 썼다면 쉬웠을 텐데 for로 돌리려고 하다가 시간을 많이 잡아먹었다. 문법을 확실하게 익히고 이해하지 못해 벌어진 일인 것 같다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/20/ap_pg_post3/"
  },{
    "title": "[프로그래머스 / lv.1] 최대공약수와 최소공배수",
    "text": "날짜: 2021년 5월 20일 소요 시간: 27분 9초 카테고리: 수학 문제 태그: 레벨1, 파이썬 코딩테스트 연습 - 최대공약수와 최소공배수 입출력 예시 n m return 3 12 [3, 12] 2 5 [1, 10] 내가 적은 코드 def solution(n, m): a = n b = m while b: a, b = b, a%b min = a max = (n/min)*(m/min)*min return [min, max] 풀이 과정 유클리드 호제법을 활용하여 최소공배수를 구했고, 두개의 인자와 최소공배수 사이의 관계를 활용하여 최대공약수를 구했다. 베스트 코드 def gcd(a, b): return b if a % b == 0 else gcd(b, a % b) def lcm(a, b): return int(a * b / gcd(a, b)) def gcdlcm(a, b): answer = [gcd(a,b), lcm(a,b)] return answer 반성 최대공약수와 최소공배수 계산을 모두 해야해서 n과m을 a와 b로 치환해서 계산하였는데, 베스트 코드는 함수를 여러개 만들었다. 로직은 모두 비슷한데 어떤 방식으로 푸는 것이 가장 효율적인지를 알고 코드를 짜는 능력을 기를 필요가 있을 것 같다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/20/ap_pg_post2/"
  },{
    "title": "[프로그래머스 / lv.1] 정수 제곱근 판별",
    "text": "날짜: 2021년 5월 20일 소요 시간: 6분 51초 카테고리: 수학 문제 태그: 레벨1, 파이썬 코딩테스트 연습 - 정수 제곱근 판별 입출력 예시 n return 121 144 3 -1 내가 적은 코드 def solution(n): if (n**(1/2))%1 == 0: return ((n**(1/2)) + 1)**2 else: return -1 풀이 과정 제곱근을 정수 1로 나누었을 때 나머지가 0이면 정수라는 로직으로 접근했다. 베스트 코드 def nextSqure(n): sqrt = n ** (1/2) if sqrt % 1 == 0: return (sqrt + 1) ** 2 return 'no' 반성 처음엔 type으로 문제를 접근 했다가 정수가 나와도 float로 출력되어 오류가 나서 시간을 많이 잡아먹었다. 베스트 코드와 같은 로직으로 접근한 첫 알고리즘 문제 인 것 같다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/20/ap_pg_post1/"
  },{
    "title": "[프로그래머스 / lv.1] 짝수와 홀수",
    "text": "날짜: 2021년 5월 19일 소요 시간: 53초 카테고리: 수학 문제 태그: 레벨1, 파이썬 코딩테스트 연습 - 짝수와 홀수 입출력 예시 nums return 3 “Odd” 2 “Even” 내가 적은 코드 def solution(num): if num%2 == 1: answer = \"Odd\" else: answer = \"Even\" return answer 풀이 과정 num을 2로 나누어 나머지가 1이면 홀수인 Odd출력, 이외는 짝수인 Even을 출력했다. 베스트 코드 def evenOrOdd(num): return \"Even\" if num%2 == 0 else \"Odd\" 반성 난이도 적으로는 제일 쉬운 문제였지만 과연 고민을 덜 하고 풀이 시간을 줄이는 것이 먼저인지, 고민을 좀 더 하더라도 시간복잡도를 줄이는 것이 먼저인지, 고민을 많이 하게 한 문제 인 것 같다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/19/ap_pg_post1/"
  },{
    "title": "[프로그래머스 / lv.1] 행렬의 덧셈",
    "text": "날짜: 2021년 5월 17일 소요 시간: 6분 11초 카테고리: 행렬 태그: 레벨1, 파이썬 코딩테스트 연습 - 행렬의 덧셈 입출력 예시 arr1 arr2 result [[1,2],[2,3]] [[3,4],[5,6]] [[4,6],[7,9]] [[1],[2]] [[3],[4]] [[4],[6]] 내가 적은 코드 import numpy as np def solution(arr1, arr2): answer = np.array(arr1) + np.array(arr2) return answer.tolist() 풀이 과정 행렬의 연산이 가능한 numpy라이브러리를 가져와 문제를 풀었다. 베스트 코드 def sumMatrix(A,B): answer = [[c + d for c, d in zip(a, b)] for a, b in zip(A,B)] return answer 반성 numpy라이브러리를 알고 있어서 가져와 풀긴 했지만 출제자의 의도는 베스트 코드가 아니었을까… 마지막 tolist()를 붙이지 않아 행렬 형태로 답이 출력되는 오류 때문에 시간이 많이 걸렸다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/17/ap_pg_post1/"
  },{
    "title": "[프로그래머스 / lv.1] 핸드폰 번호 가리기",
    "text": "날짜: 2021년 5월 16일 소요 시간: 15분 5초 카테고리: 인덱싱 태그: 레벨1, 파이썬 코딩테스트 연습 - 핸드폰 번호 가리기 입출력 예시 phone_number return “01033334444” “***4444” “027778888” “*****8888” 내가 적은 코드 def solution(phone_number): answer = \"*\"*(len(phone_number)-4)+phone_number[len(phone_number)-4:] return answer 풀이 과정 phone_number의 길이 -4의 개수만큼 문자열*을 출력하고 phone_number의 길이 -4 부터 끝까지의 문자열을 슬라이싱하여 뒤에 붙였다. 베스트 코드 def hide_numbers(s): return \"*\"*(len(s)-4) + s[-4:] 반성 이전에 다른 곳에서 한 번 풀어 본 문제라서 대략적인 알고리즘은 기억이 났다. 자료형에 대한 이해도가 낮아서 문자열을 컴파일 하는 단계에서 자꾸 오류가 나서 시간이 오래걸렸다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/16/ap_pg_post4/"
  },{
    "title": "[프로그래머스 / lv.1] 2016년",
    "text": "날짜: 2021년 5월 16일 소요 시간: 1분 28초 카테고리: 수학문제 태그: 레벨1, 파이썬 코딩테스트 연습 - 2016년 입출력 예시 a b result 5 24 “TUE” 내가 적은 코드 import datetime def solution(a, b): days = ['MON','TUE','WED','THU','FRI','SAT','SUN'] answer = days[datetime.date(2016,a,b).weekday()] return answer 풀이 과정 datetime 라이브러리를 가져와서 2016년 a월 b일의 요일을 출력했다. 베스트 코드 def getDayName(a,b): months = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] days = ['FRI', 'SAT', 'SUN', 'MON', 'TUE', 'WED', 'THU'] return days[(sum(months[:a-1])+b-1)%7] 반성 코드를 짧게하기 위해 datetime 모듈을 들고왔다. 모듈을 굳이 들고오지않아도 수식으로 나와 시간복의 코드를 짠 사람이 있었다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/16/ap_pg_post3/"
  },{
    "title": "[프로그래머스 / lv.1] 평균 구하기",
    "text": "날짜: 2021년 5월 16일 소요 시간: 7분 34초 카테고리: 수학문제 태그: 레벨1, 파이썬 코딩테스트 연습 - 평균 구하기 입출력 예시 arr return [1,2,3,4] [2.5] [5,5] [5] 내가 적은 코드 def solution(arr): k = 0 for i in range(0,len(arr)): k += arr[i] answer = k / len(arr) return answer 풀이 과정 arr안의 원소들을 반복문을 모두 더한 다음 arr의 길이만큼 나누었다. 베스트 코드 def average(list): return (sum(list) / len(list)) 반성 sum 함수를 기억해내지 못해 쓸떼 없는 반복문을 썼다. 그리 어렵지 않은 문제를 어렵게 접근하려 했다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/16/ap_pg_post2/"
  },{
    "title": "[프로그래머스 / lv.1] 제일 작은 수 제거하기",
    "text": "날짜: 2021년 5월 16일 소요 시간: 21분 56초 카테고리: 수학문제 태그: 레벨1, 파이썬 코딩테스트 연습 - 제일 작은 수 제거하기 입출력 예시 arr return [4,3,2,1] [4,3,2] [10] [-1] 내가 적은 코드 def solution(arr): k = arr[0] if len(arr) == 1: arr[0] = -1 else: for i in range(1,len(arr)): if k &gt; arr[i]: k = arr[i] i += 1 arr.remove(k) answer = arr return answer 풀이 과정 arr안의 원소들을 차례로 비교하며 가장 작은 수를 찾아 내서 remove함수로 지우도록 만들었다. 정렬 알고리즘과 가깝게 풀려고 했었던 것 같다. 베스트 코드 def rm_small(mylist): return [i for i in mylist if i &gt; min(mylist)] or [-1] 내 생각에 가장 직관적인 코드 def rm_small(mylist): mylist.remove(min(mylist)) return mylist # 빈 리스트와 리스트 원소가 1개일 때는 고려하지 않은 코드 반성 min(array[]) 함수를 알지 못해 코드가 길어졌다. 사실은 반복을 쓸 필요도 없는 문제였다. 리스트 안에 반복문 조건문을 삽입 할 수 있다는 점을 몰랐다. 함수의 활용 등의 전반적인 파이썬 언어에 대한 이해도를 높일 필요가 있다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/16/ap_pg_post1/"
  },{
    "title": "[프로그래머스 / lv.1] 약수의 개수와 덧셈",
    "text": "날짜: 2021년 5월 15일 소요 시간: 30분 21초 카테고리: 수학 태그: 레벨1, 파이썬 코딩테스트 연습 - 약수의 개수와 덧셈 입출력 예시 left right result 13 17 43 24 27 52 내가 적은 코드 def solution(left, right): answer = 0 for num in range(left,right+1): measure_count = 0 for measure_check in range(1,num+1): if num % measure_check == 0: measure_count += 1 if measure_count % 2 == 0: answer += num else: answer -= num return answer 풀이 과정 left에서 right까지의 수를 반복문을 활용해서 하나씩 약수의 개수를 체크했다. 1부터 num까지 차례차례 num을 나누었을 때 나머지가 0이 되면 measure_count를 1 증가시켜 measure_count를 2로 나눈 나머지를 통해 약수의 개수가 짝수개인지 홀수개인지를 판별했다. 베스트 코드 def solution(left, right): answer = 0 for i in range(left,right+1): if int(i**0.5)==i**0.5: answer -= i else: answer += i return answer 반성 알고리즘 문제를 많이 풀지 않아서 익숙하지 않은 탓인지 기본적인 수학문제임에도 시간을 많이 썼다. range(a,b)의 이해도가 낮아 +1을 놓쳐 해맸다. 베스트 코드 짜는 애들은 약수의 개수가 홀수개면 0.5제곱하면 정수로 떨어진다는 걸 어떻게 생각을 해내지…",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/15/ap_pg_post2/"
  },{
    "title": "[프로그래머스 / lv.1] 가운데 글자 가져오기",
    "text": "날짜: 2021년 5월 15일 소요 시간: 5분 48초 카테고리: 인덱싱 태그: 레벨1, 파이썬 코딩테스트 연습 - 가운데 글자 가져오기 입출력 예시 s return “abcde” “c” “qwer” “we” 내가 적은 코드 def solution(s): half_s = len(s)//2 if len(s)%2 == 1: answer = s[half_s] else: answer = s[half_s-1:half_s+1] return answer 풀이 과정 s 길이를 반으로 나누었을 때 나머지가 1이면(문자열의 길이가 홀수이면) ‘길이의 반’번째 있는 문자(하나)를 가져왔고 나머지가 0이면(문자열의 길이가 짝수이면) ‘길이의 반-1’~’길이의 반’번째 있는 문자(둘)를 가져왔다. 베스트 코드 def string_middle(str): return str[(len(str)-1)//2:len(str)//2+1] 반성 인덱스 슬라이싱의 개념을 확실하게 잡지 못해 s[a:b] 부분을 헷갈려서 시간이 많이 소요되었다. 사실 다시 코드 짜라고 해도 베스트 코드는 생각 못해낼 것 같긴하다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/15/ap_pg_post1/"
  },{
    "title": "[프로그래머스 / lv.1] 폰켓몬",
    "text": "날짜: 2021년 5월 5일 소요 시간: 10분 32초 카테고리: 배열, 인덱스 태그: 레벨1, 파이썬 코딩테스트 연습 - 폰켓몬 입출력 예시 nums result [3,1,2,3] 2 [3,3,3,2,2,4] 3 [3,3,3,2,2,2] 2 내가 적은 코드 def solution(nums): array = [] for x in nums: if x not in array: array.append(x) else: continue if len(nums)/2 &lt; len(array): answer = len(nums)/2 else: answer = len(array) return answer 풀이 과정 nums안의 중복되지 않은 원소 찾기위해 for문을 돌려 새로운 배열을 만들어 그 곳에 원소를 저장하였고 남은 폰켓몬의 길이가 N/2마리의 폰켓몬 보다 크면 가질 수 있는 폰켓몬의 수가 정답이고, 반대이면 array의 길이가 정답이다. 베스트 코드 def solution(ls): return min(len(ls)/2, len(set(ls))) 반성 set()에 대한 이해도가 낮아서 굳이 for과 if를 하나 더 넣어서 복잡도를 높였다. return값이 굳이 answer이 아니어도 된다는 것을 깨달았다.",
    "tags": "programers algorithmpractice",
    "url": "/algorithmpractice/2021/05/05/ap_pg_post1/"
  }]};
